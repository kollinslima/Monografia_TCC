\chapter{Resultados e Discussões}
\label{Resultados}

\par Nesta seção, serão apresentados os resultados obtidos com as modificações da IDE do Arduino e com o simulador para Android, bem como algumas métricas de \textit{software} obtidas para o simulador.

\section{Arduino IDE}

\par A figura~\ref{fig:ide_modificada} mostra o como ficou a IDE do Arduino após a introdução do botão "Android".

 \begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/android_button}
	\caption{Localização do botão "Android" (Selecionado) na IDE.} 
	Fonte: Autor
	\label{fig:ide_modificada}
\end{figure}

\par Ao pressionar o botão "Android", o processo de compilação se inicia e, em caso de sucesso, é exibida a janela para a seleção do dispositivo Android conectado ao PC, como mostrado na figura~\ref{fig:selecionar_dispositivo}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/device_selector}
	\caption{Seletor de dispositivos.} 
	Fonte: Autor
	\label{fig:selecionar_dispositivo}
\end{figure}

\par Ao selecionar o dispositivo, o usuário pode ativar a opção "\textit{Set as default device}". Isso fará com que a opção escolhida seja salva e não exibirá o seletor de dispositivos nas próximas compilações.
\par Se tudo ocorreu como o esperado, o usuário deve ver a mensagem de cópia no \textit{console} abaixo do editor, conforme mostra a figura~\ref{fig:console_sucesso}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/copy_success}
	\caption{Cópia do arquivo realizada com sucesso para o \textit{smartphone}} 
	Fonte: Autor
	\label{fig:console_sucesso}
\end{figure}

\section{Simulador}
\label{resultado_sofia}

\par Ao abrir o simulador, o usuário é recebido com uma \textit{Splash Screen}, mostrada na figura~\ref{fig:splash_screen}, enquanto o banco de dados é carregado para a memória.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.25\textwidth]{./Resources/splash_screen}
	\caption{\textit{Splash Screen} exibida ao abrir o simulador.} 
	Fonte: Autor
	\label{fig:splash_screen}
\end{figure}

\par O usuário é então redirecionado para a tela inicial do simulador, mostrada na figura~\ref{fig:tela_inicial}
\vfill

\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth]{./Resources/tela_inicial}
	\caption{Tela inicial do simulador.} 
	Fonte: Autor
	\label{fig:tela_inicial}
\end{figure}

\par Na parte superior do simulador se concentram as opções para que o usuário comece a utilizar o sistema, bem como informações sobre o estado da simulação. Nesta \textit{toolbar}, o usuário tem acesso às seguintes opções:

\begin{enumerate}
\item \textbf{Modelo simulado}: Mostra qual placa de Arduino está sendo utilizada para a simulação.
\item \textbf{Botão \textit{Reset}}: Permite o \textit{reset} manual do sistema.
\item \textbf{Adicionar Entrada/Saída}: Permite adicionar uma entrada/saída digital ou uma entrada analógica, bem como um monitor serial.
\item \textbf{Outras opções}: Contém funções adicionais para importar código do \textit{smartphone}, mapa de memória, configuração de tensão de referência (para o conversor A/D), remover todas as entradas/saídas, ajuda e acesso à informações do projeto.
\end{enumerate}

\par Além disso, o usuário pode visualizar:

\begin{enumerate}
	\setcounter{enumi}{4}
\item \textbf{Tempo simulado}: Exibe tempo simulado do sistema, baseado no cristal de 16MHz e atualizado a cada pulso de \textit{clock} interno do sistema.
\item \textbf{Status}: Mostra o \textit{status} da simulação.
\item \textbf{Área de Trabalho}: Onde serão dispostos os elementos de entrada e saída.
\end{enumerate}

\par Caso não seja encontrado um arquivo hexadecimal ou ocorra alguma falha na abertura, o usuário deve ver uma mensagem na barra de \textit{status} informando o problema, como mostrado na figura~\ref{fig:hex_file_not_found}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.3\textwidth]{./Resources/hex_file_not_found}
	\caption{Falha ao abrir arquivo hexadecimal} 
	Fonte: Autor
	\label{fig:hex_file_not_found}
\end{figure}

\subsection{Interação com o sistema}

\par O usuário interage com o sistema por meio de entradas e saídas no simulador. Uma saída digital é mostrada na figura~\ref{fig:saida_digital}. No lado esquerdo é possível selecionar o pino no qual a saída estará conectada e do lado direito é mostrado o estado do pino. Por padrão, o pino 13 é selecionado uma vez que este é o pino onde o led interno está conectado no Arduino UNO. A figura~\ref{fig:saida_digital} mostra os três estados possíveis para uma saída no simulador.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/outputs}
	\caption{Saídas digitais do simulador} 
	Fonte: Autor
	\label{fig:saida_digital}
\end{figure}

\par Uma entrada pode ser digital ou analógica. Uma entrada digital é mostrada na figura~\ref{fig:entrada_digital}. Pode-se observar que existem 4 elementos em uma entrada digital, são eles (da esquerda para a direita):

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/inputs}
	\caption{Entradas digitais do simulador.} 
	Fonte: Autor
	\label{fig:entrada_digital}
\end{figure}

\begin{itemize}
\item \textbf{Botão}: por onde o usuário envia sinais ao o sistema.
\item \textbf{Seletor de modo}: define a operação do botão, podendo ser:
	\begin{itemize}
	\item Push-GND: envia nível baixo se pressionado, indefinido caso contrário (é a opção padrão).
	\item Push-VDD: envia nível alto se pressionado, indefinido caso contrário.
	\item Pull-Up: envia nível baixo se pressionado, alto caso contrário.
	\item Pull-Down: envia nível alto se pressionado, baixo caso contrário.
	\item Toggle: alterna seu nível a cada toque no botão.
	\end{itemize}
\item \textbf{Seletor de pino}: define para qual pino do Arduino o sinal deve ser enviado.
\item \textbf{Saída do sinal}: mostra o que está sendo enviado para o pino selecionado
\end{itemize}

\par Por padrão, nenhum pino está selecionado. Isso garante que não haverá um curto-circuito ao adicionar uma entrada. Em caso de curto-circuito, é exibida uma mensagem na barra de status (como mostra a figura~\ref{fig:curto-circuito}) e a simulação para, podendo ser reiniciada manualmente assim que a condição de curto-circuito for removida.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/short_circuit}
	\caption{Condição de cuito-circuito entre entradas.} 
	Fonte: Autor
	\label{fig:curto-circuito}
\end{figure}

\par Uma entrada analógica é mostrada na figura~\ref{fig:entrada_analogica}. Ela possui um seletor de pino, uma barra deslizante e um voltímetro, indicando o valor de tensão enviado ao Arduino. Assim como na entrada digital, nenhuma entrada está selecionada por padrão.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/analog_input}
	\caption{Entradas analógicas do simulador.} 
	Fonte: Autor
	\label{fig:entrada_analogica}
\end{figure}

\par Caso se queira remover uma entrada/saída, pode-se utilizar um toque longo na célula desejada e selecionar quais elementos serão removidos, como mostra a figura~\ref{fig:remocao}. Alternativamente, pode-se utilizar a opção "\textit{Clear I/O}" da \textit{toolbar} para remover todas as entradas e saídas.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/remocao}
	\caption{Remoção manual de pinos de saída.} 
	Fonte: Autor
	\label{fig:remocao}
\end{figure}

\subsection{Monitor Serial}

\par Outro modo de interação com o sistema é por meio do monitor serial, mostrado na figura~\ref{fig:monitor_serial}. Este monitor pode ser utilizado para receber ou enviar informações para a USART e ocupa o mesmo espaço reservado para as saídas digitais, ou seja, não é possível visualizar as saídas em conjunto com o monitor serial (é possível, no entanto, utilizá-lo simultaneamente com entradas). 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.25\textwidth]{./Resources/serial_monitor_working}
	\caption{Monitor Serial.} 
	Fonte: Autor
	\label{fig:monitor_serial}
\end{figure}

\par O monitor serial pode ser removido também com a opção "\textit{Clear I/O}" ou clicando no "x" na parte superior.

\subsection{Mapa de memória}

\par O recurso de mapa de memória é apresentado na figura~\ref{fig:mapa_memoria}. Este recurso permite ao usuário ver e acompanhar o estado de cada bit da memória de dados enquanto a simulação continua funcionando, bem como verificar qual o uso total de memória pelo sistema em bytes e em porcentagem.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.25\textwidth]{./Resources/memory_map}
	\caption{Mapa de memória.} 
	Fonte: Autor
	\label{fig:mapa_memoria}
\end{figure}

\par Toda a memória (2kB) somado aos registradores podem ser visualizados com esta função. Para facilitar a busca por um endereço específico, os registradores foram nomeados e adicionou-se o recurso de busca, que pode ser acessado pelo ícone de lupa no canto superior direito. A figura~\ref{fig:mapa_memoria_busca} mostra a busca sendo utilizada para encontrar o registrador TCNTx.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.25\textwidth]{./Resources/memory_map_search}
	\caption{Recurso de busca do mapa de memória.} 
	Fonte: Autor
	\label{fig:mapa_memoria_busca}
\end{figure}

\subsection{Referência externa de tensão}

\par Outro recurso que foi inserido no simulador foi a configuração da referência externa de tensão para conversão analógica. Em \textit{hardware}, esta referência é aplicada no pino AREF e utilizada como base para conversão. No simulador, pode-se utilizar o menu "\textit{AREF Config}" para simular esta função. A figura~\ref{fig:aref_config} mostra a tela de configuração exibida.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.25\textwidth]{./Resources/AREF_config}
	\caption{Configuração de tensão externa aplicada ao pino AREF, usada como base para conversão A/D.} 
	Fonte: Autor
	\label{fig:aref_config}
\end{figure}

\par Por padrão, o valor configurado é de 5V (como mostra a figura~\ref{fig:aref_config}). Este valor pode ser alterado para qualquer valor real que esteja dentro das epecificações mínimas e máximas apresentadas na folha de dados do ATmega328P (Mínimo: 1V, Máximo: 5V).

\subsection{Medição de frequência}

\par Caso a frequência de oscilação de um pino de saída seja muito alta, o simulador não será capaz de exibir esta intermitência corretamente devido a limitações de velocidade da atualização da tela do Android (máximo 60fps). Nestes casos, pode-se utilizar o recurso de frequencímetro integrado ao simulador para verificar a qual frequência a saída está alterando seu estado.(Na verdade, pode-se utilizar o frequencímetro em qualquer ocasião, este é apenas um caso onde seu uso se faz absolutamente necessário para depuração.)

\par Para medir frequência em um pino de saída, basta pressionar a saída desejada com um toque longo e selecionar frequencímetro (figura~\ref{fig:frequencimetro_icone}). Os valores de frequência e \textit{duty cicle} aparecerão na célula de saída, como mostra a figura~\ref{fig:frequencimetro}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/frequency_meter_icon}
	\caption{Ícone do frequencímetro.} 
	Fonte: Autor
	\label{fig:frequencimetro_icone}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/frequency_meter}
	\caption{Frequencímetro em funcionamento.} 
	Fonte: Autor
	\label{fig:frequencimetro}
\end{figure}

\par A medição de frequência implementada se mostrou bastante precisa quando comparada com as medições reais de frequência. Para realizar os testes, foram utilizados os projetos \textit{Blink} e \textit{Timer1}, apresentados no Apêndices~\ref{apendice_blink} e~\ref{apendice_timer}.
\par O projeto \textit{Blink} foi utilizado ora com a função \textit{delay}, ora com função \textit{delayMicroseconds}, desta forma podendo obter diferentes valores de frequência gerados por diferentes métodos.
\par O projeto \textit{Timer1} foi modificado para utilizar o modo \textit{FastPWM}. Esta alteração foi feita somente para facilitar a alteração dos valores de frequência por meio do valor nos registradores OCR1A/ICR1.

\par As tabelas~\ref{tab:comparacao_frequencia} e~\ref{tab:comparacao_duty} apresentam os valores medidos de frequência obtidos com o simulador e com o osciloscópio ligado ao Arduino, bem como o erro relativo de cada medição. 
\par Como pode ser observado, o simulador e o Arduino se comportam de maneira semelhantes tanto na geração de frequência quanto nas características do \textit{duty cicle}, apresentando um erro relativo alto quando se trabalha com altas frequências, bem como uma dificuldade na geração/medição de pequenos valores de \textit{duty cicle}. 

\par Com isso, conclui-se que o frequencímetro incluso no simulador fornece medições satisfatórias, principalmente se a aplicação desenvolvida não tiver grandes exigências o parâmetro de frequência e \textit{duty cicle}. Notou-se apenas uma certa instabilidade nos valores quando as medições eram feitas em altas frequências (principalmente após um \textit{reset} manual), mas nada crítico ao ponto de não permitir o uso e a leitura correta das grandezas.

\begin{table}[h]
	\centering
	\caption{Comparação das medições de frequência.}
	\label{tab:comparacao_frequencia}
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		\multirow{2}{*}{\textbf{Função}} & \multirow{2}{*}{\textbf{Período}} & \multicolumn{3}{c|}{\textbf{Frequência (Hz)}} & \multicolumn{2}{c|}{\textbf{Erro (\%)}} \\ \cline{3-7} 
		&                   & Exata & SOFIA & Arduino & SOFIA & Arduino   \\ \hline
		\multirow{3}{*}{\textit{delayMicroseconds}} 
		& 2$\mu$s     & 500000 & 145455 & 145370 & 70,91 & 70,93 \\ \cline{2-7} 
		& 20$\mu$s    & 50000  & 41026  & 41000  & 17,95 & 18,00 \\ \cline{2-7} 
		& 200$\mu$s   & 5000   & 4893   & 4890   & 2,14  & 2,2          \\ \hline
		\multirow{2}{*}{\textit{delay}} 
		&  2ms  & 500 & 496 & 495 & 0,80 & 1,00 \\ \cline{2-7} 
		&  4ms  & 250 & 249 & 248 & 0,40 & 0,80 \\ \hline
		\multirow{5}{*}{\textit{Timer1}} 
		& 125ns     & 8000000 & 40201 & 40180 & 99,5 & 99,5     \\ \cline{2-7} 
		& 2$\mu$s   & 500000  & 40201 & 40180 & 91,96 & 91,96     \\ \cline{2-7} 
		& 32$\mu$s  & 31250   & 19735 & 19741 & 36,85 & 36,83     \\ \cline{2-7} 
		& 512$\mu$s & 1953,13 & 1885  & 1883  & 3,49  & 3,59     \\ \cline{2-7} 
		& 7,68ms    & 130,21  & 130   & 129,8 & 0,16  & 0,31      \\ \hline
	\end{tabular}
\end{table}

\begin{table}[H]
	\centering
	\caption{Comparação das medições de \textit{duty cicle}.}
	\label{tab:comparacao_duty}
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		\multirow{2}{*}{\textbf{Função}} & \multirow{2}{*}{\textbf{Frequência (Hz)}} & \multicolumn{3}{c|}{\textbf{\textit{Duty Cicle} (\%)}} & \multicolumn{2}{c|}{\textbf{Erro (\%)}} \\ \cline{3-7} 
		&                   & Exata & SOFIA & Arduino & SOFIA & Arduino   \\ \hline
		\multirow{3}{*}{\textit{delayMicroseconds}} 
		& 5000    & 50    & 50 & 49,97 & 0    & 0,06  \\ \cline{2-7} 
		& 9090,91 & 9,09  & 11 & 10,06 & 21   & 16,6  \\ \cline{2-7} 
		& 9900,99 & 0,99  & 3  & 3,02  & 203  & 223,2 \\ \cline{2-7}
		& 9090,91 & 90,91 & 89 & 89,3  & 2,1  & 1,77  \\ \cline{2-7} 
		& 9900,99 & 99,91 & 97 & 96,7  & 2,03 & 2,333 \\ \hline
		\multirow{2}{*}{\textit{delay}} 
		& 500    & 50    & 50 & 50   & 0   & 0  \\ \cline{2-7} 
		& 333,33 & 66,67 & 67 & 66,5 & 0,5 & 0,25 \\ \cline{2-7} 
		& 250    & 75    & 75 & 74,8 & 0 & 0,27 \\ \cline{2-7} 
		& 333,33 & 33,33 & 33 & 33,5 & 1 & 0,5 \\ \cline{2-7} 
		& 250    & 25    & 25 & 25,1 & 0 & 0,4 \\ \hline
		\multirow{5}{*}{\textit{Timer1}} 
		& 31189,08 & 99,81 & 100 & 99,63 & 0,2  & 0,18      \\ \cline{2-7} 
		& 31189,08 & 96,88 & 97  & 96,7  & 0,12 & 0,19     \\ \cline{2-7} 
		& 31189,08 & 50,1  & 50  & 49,9  & 0,19 & 0,39     \\ \cline{2-7} 
		& 31189,08 & 46,98 & 47  & 46,8  & 0,05 & 0,38     \\ \cline{2-7} 
		& 31189,08 & 3,31  & 3   & 3,12  & 9,47 & 5,85     \\ \cline{2-7} 
		& 31189,08 & 0,39  & 0   & 0,19  & 100  & 51,27      \\ \hline
	\end{tabular}
\end{table}

\section{Métricas de \textit{Software}}

\subsection{Análise Estática}

\par Com o uso do SonarQube, foi realizada a analise estática do código com o objetivo principal de identificar e corrigir problemas relacionados à segurança, vulnerabilidades e manutenibilidade. O SonarQube fornece diversas métricas a respeito do projeto, além de classificar a qualidade do \textit{software} com notas variando de A (melhor qualidade) a E (pior qualidade).
\par A primeira métrica relevante que a ferramenta fornece é uma medida de confiabilidade do sistema, baseada no número de \textit{bugs}. A figura~\ref{fig:confiabilidade} mostra um gráfico relacionando cada classe do projeto com a quantidade de \textit{bugs} encontrados (tempo para correção dos defeitos). Pode-se observar que uma classe se destaca pela sua quantidade de \textit{bugs}, esta classe é a \textit{DataMemory\_ATmega328P}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/confiabilidade}
	\caption{Gráfico linhas de código x esforço para resolução dos \textit{bugs}.} 
	Fonte: Autor
	\label{fig:confiabilidade}
\end{figure}
 
\par É importante ressaltar que, por ser uma ferramenta de análise estática, muitos problemas apontados podem não se aplicar ao projeto ou ser falsos positivos. Em se tratando de \textit{bugs}, dos problemas que não foram resolvidos sobraram apenas \textit{bugs} relacionados ao tratamento de exceções (que está sendo feito com o uso de \textit{Logs}, no Android Studio) e à conversão (\textit{cast}) de valores (os casos de teste criados com o JUnit4 estão testando estas conversões). 
\par Devido à estes problemas o sistema receberia classificação C em termos de confiabilidade, no entanto foi atribuída a nota E devido à um \textit{bug} identificado na classe \textit{DataBaseHelper} relacionado à abertura e fechamento do banco de dados (apesar de ter sido corrigido conforme a sugestão proposta).

\par Outra métrica fornecida diz respeito à segurança do sistema e se baseia na quantidade de vulnerabilidades encontradas. A figura~\ref{fig:seguranca} apresenta um gráfico relacionando cada classe do projeto com a quantidade de vulnerabilidades (tempo para correção dos defeitos). Novamente, observa-se uma classe em destaque, esta é a \textit{OutputFragment\_Atmega328P}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/seguranca}
	\caption{Gráfico linhas de código x esforço para resolução das vulnerabilidades.} 
	Fonte: Autor
	\label{fig:seguranca}
\end{figure} 

\par Em termos de vulnerabilidades, o sistema apresenta melhores resultados em comparação aos \textit{bugs}. Das que não foram resolvidas, sobraram vulnerabilidades relacionadas à manipulação de variáveis estáticas. Muitas destas, no entanto, são variáveis privadas, de forma que não existem grandes problemas relacionado com o acesso delas por classes externas.O sistema foi classificado com o \textit{ranking} B para segurança.

\par A próxima métrica obtida diz respeito a manutenibilidade do código. Esta medida é feita com base na compexidade cognitiva dos métodos e quanto ao uso devido/indevido de padrões de codificação (esses são chamados \textit{Code Smells}). A figura~\ref{fig:manutencao} apresenta um gráfico relacionando cada classe do projeto com a quantidade de \textit{Code Smells} encontrados (tempo para correção dos defeitos). A classe com maior número de problemas para essa métrica é a \textit{Timer1\_ATmega328P}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/manutencao}
	\caption{Gráfico linhas de código x esforço para resolução dos \textit{Code Smells}.} 
	Fonte: Autor
	\label{fig:manutencao}
\end{figure} 

\par Muitos dos problemas apontados nesta categoria são de menor importância, tais como remover linhas comentadas, mudar nomes de variáveis, etc. Os problemas de maior importância são os de complexidade cognitiva, que indicam que um método está muito grande, tornando-o de difícil compreensão. No entanto, alguns destes métodos não podem ser refatorados facilmente, já que comprometeria a arquitetura geral do projeto.
\par Outro problema apontado quanto à manutenibilidade foi a quantidade de níveis de herança que algumas classes possuem, excedendo o limite de 5 níveis. Não há muito o que fazer nestes casos, já que estas classes não herdam de nenhum código desenvolvido, mas de classes do próprio sistema Android (como a \textit{AppCompatActivity}). Este foi o principal motivo para que o sistema fosse classificado com o \textit{ranking} C para manutenibilidade.

\par Também foi obtida uma métrica de código duplicado. A figura~\ref{fig:duplicacao} apresenta um gráfico relacionando cada classe do projeto com a quantidade de linhas de código duplicadas. 

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/duplicacao}
	\caption{Gráfico linhas de código x linhas de código duplicadas.} 
	Fonte: Autor
	\label{fig:duplicacao}
\end{figure} 

\par As classes com maior número de código duplicado são as classes referentes aos \textit{Timers} (O \textit{Timer1} é a classe em destaque na figura~\ref{fig:duplicacao}) e a CPU. Os modos de operação dos \textit{Timers} se assemelham em muitos aspectos, no entanto, escrever um único método para gerenciar todos estes modos certamente o tornaria grande e complexo (gerando um problema na métrica de complexidade cognitiva) e portanto, foram criados diferentes métodos, cada um com pequenas diferenças de modo a atender o modo de operação configurado. Da mesma forma, várias instruções da CPU realizam a leitura e a escrita dos valores na memória de maneira idêntica, mas suas operações são diferentes de modo que também não é possível unir códigos de diferentes instruções.

\par A última métrica importante de ser mencionada é a de complexidade ciclomática. Esta é uma media importante pois diz qual é o número mínimo de casos de teste necessários para que eles cubram todo o projeto. O valor obtido para complexidade ciclomática foi de 1.969.

\subsection{Cobertura}

\par Foram criados teste de unidade para todos os principais módulos do projeto (CPU, memórias de dado e de programa, ADC, \textit{Timers}, USART e módulo de interrupção), totalizando 808 casos de teste. O foco dos testes foi principalmente a cobertura de linhas e condicionais e análise de valor limite, este último sendo o foco dos testes na CPU.

\par A cobertura dos testes criado foi medida tanto com a ferramenta interna do Android Studio quanto com o plugin JaCoCo (integrado ao SonarQube). Houve uma diferença de 10\% nas duas medidas de cobertura por estas ferramentas, com o Android Studio registrando 59\% de cobertura e o JaCoCo 49\%, como mostram as figuras~\ref{fig:cobertura_android_studio} e~\ref{fig:cobertura_jacoco}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.65\textwidth]{./Resources/cobertura_android_studio}
	\caption{Medida de cobertura do projeto obtida com o  Android Studio.} 
	Fonte: Autor
	\label{fig:cobertura_android_studio}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/cobertura_jacoco}
	\caption{Medida de cobertura do projeto obtida com o JaCoCo.} 
	Fonte: Autor
	\label{fig:cobertura_jacoco}
\end{figure}

\par A cobertura dos testes por módulo são apresentadas nas figuras~\ref{fig:cobertura_modulo_android_studio} e~\ref{fig:cobertura_modulo_jacoco}. A partir destes dois gráficos apresentados, pode-se dizer que a medição realizada pelo Android Studio se mostra mais exata ao que foi feito, já que as medidas do JaCoCo indicam uma cobertura de 0\% para a USART, quando existem 7 casos de teste para este módulo, e 100\% para módulo de E/S, quando não foi escrito nenhum caso de teste para este módulo, já que este é mais dedicado à operações com interface gráfica.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{./Resources/cobertura_modulo_android_studio}
	\caption{Cobertura por módulo (Android Studio).} 
	Fonte: Autor
	\label{fig:cobertura_modulo_android_studio}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{./Resources/cobertura_modulo_jacoco}
	\caption{Cobertura por módulo (JaCoCo).} 
	Fonte: Autor
	\label{fig:cobertura_modulo_jacoco}
\end{figure}

\par Além dos testes automatizados, foram realizados testes manuais das funcionalidades desenvolvidas. Todos os códigos testados podem ser vistos na seção de apêndice deste trabalho.

\subsection{\textit{Profiling}}

\par Foi utilizada a ferramenta de \textit{profilling} do próprio Android Studio para avaliar o consumo de recursos do aplicativo e tentar identificar pontos de otimização. O projeto \textit{Blink} (apêndice~\ref{apendice_blink}), foi utilizado no simulador durante a execução do \textit{profilling}. 
\par O sistema foi avaliado quanto ao seu uso de CPU e memória, a figura~\ref{fig:profilling_geral} mostra o desempenho do sistema considerando estes dois fatores. Pode-se observar que o uso de CPU fica em torno de 25\%, enquanto que o uso de memória é de aproximadamente 30MB.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{./Resources/profilling_general}
	\caption{Uso de CPU e memória para o projeto \textit{Blink}.} 
	Fonte: Autor
	\label{fig:profilling_geral}
\end{figure} 

\par Olhando especificamente para a CPU (utilizando a opção de gravação instrumentada para rastreamento de métodos), observou-se que o muito do uso de CPU não está relacionado diretamente com as classes desenvolvidas, mas sim com chamadas à classes internas do Android. Do que foi desenvolvido, a classe \textit{UCModule\_View} se mostra o principal ponto crítico, mais especificamente o método \textit{run}, que faz a atualização do tempo simulado na tela. A figura~\ref{fig:profilling_cpu} apresenta este resultado.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/profilling_cpu}
	\caption{Tempo de uso da CPU (medido em uma janela de 5 minutos).} 
	Fonte: Autor
	\label{fig:profilling_cpu}
\end{figure} 

\par Uma medida tomada quanto à este resultado foi atrasar a atualização do tempo simulado por um fator de 1024, ou seja, uma requisição de atualização da tela só é dada após 1024 passagens pelo método \textit{run}. O valor de 1024 foi obtido experimentalmente de modo a não prejudicar a fluidez da interface. Valores maiores fazem com que o tempo simulado salte de um valor para outro, dando a impressão que o sistema está a ponto de travar. 
\par Essa medida teve um impacto significativo no desempenho deste método, passando de 17\% de tempo de CPU para pouco menos de 0,5\% , como mostra a figura~\ref{fig:profilling_cpu_melhoria}.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{./Resources/profilling_cpu_melhoria}
	\caption{Tempo de uso da CPU após melhoria no método \textit{run} (medido em uma janela de 5 minutos).} 
	Fonte: Autor
	\label{fig:profilling_cpu_melhoria}
\end{figure} 

\par Também foi feito um \textit{profilling} específico para o uso de memória. Os resultados são mostrados na figura~\ref{fig:profilling_memoria}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/profilling_memoria}
	\caption{Consumo de memória (medido em uma janela de 5 minutos).} 
	Fonte: Autor
	\label{fig:profilling_memoria}
\end{figure} 

\par O que se observa em termos de memória é que as estruturas de \textit{Enum}, utilizadas na CPU e nos temporizadores, foram as responsáveis por fazer com que estes módulos se destacassem no uso de memória. De certa forma, este resultado já era esperado uma vez que estas são estruturas estáticas, o que demanda um maior tamanho em memória e não são limpas pelo \textit{Garbage Collector} do Java.

\par Por outro lado, o uso de \textit{Enum} permitiu obter uma funcionalidade próxima aos ponteiros de função que se tem na linguagem C, recurso bastante útil para fazer a decodificação das instruções na CPU (bem como a seleção do \textit{prescaler} nos temporizadores). 

\par Como mencionado na seção~\ref{teoria_cpu}, manter a legibilidade do código durante a decodificação foi uma grande preocupação durante o desenvolvimento. O uso de memória é um preço a se pagar por essa facilidade obtida com a estrutura \textit{Enum}. Mesmo assim, o aplicativo não apresenta valores elevados de consumo de memória quando comparado outros com funcionalidades semelhantes, como mostra a seção~\ref{comparacao}.

\section{Comparação entre aplicativos}
\label{comparacao}

\par Foram 3 os aplicativos selecionados para serem comparados com o projeto SOFIA, são eles:

\begin{itemize}
	\item Arduino Simulator Mini Free
	\item BoardMicro - AVR Simulator (aplicativo e \textit{web}).
	\item AndMCU
\end{itemize}

\par Apesar de o aplicativo \textit{AndMCU} não estar diretamente relacionado com Arduino ou a arquitetura AVR, seu propósito é basicamente o mesmo do proposto que é proposto neste trabalho e portanto decidiu-se por analisá-lo também.

\par Para a realização dos testes, foi utilizado novamente o projeto \textit{Blink} do apêndice~\ref{apendice_blink} nos simuladores \textit{BoardMicro - AVR Simulator} e SOFIA. O aplicativo \textit{Arduino Simulator Mini Free} não permite a edição de códigos, mas possui o mesmo projeto disponível para simulação. Quanto ao \textit{AndMCU}, foi escrito um programa em \textit{assembly} com a mesma função, este mostrado no apêndice~\ref{apendice_blink_asm}.

\subsection{Interface}

\par O primeiro ponto a ser comparado são as interfaces que cada aplicativo oferece para ao usuário.

\par O projeto SOFIA, como já foi mostrado na seção~\ref{resultado_sofia}, procura oferecer uma interface simples, sem fazer referência à componentes eletrônicos. Na tela principal, o usuário tem sempre a sua disposição botões para realizar todas as tarefas que desejar no aplicativo, seja inserir novos elementos, reiniciar a simulação ou acessar funções adicionais, tudo isso sem que seja necessário acessar novas telas. A figura~\ref{fig:interface_sofia} mostra a interface principal da SOFIA com algumas entradas e saídas.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{./Resources/simulation_with_io}
	\caption{Tela principal do simulador SOFIA.} 
	Fonte: Autor
	\label{fig:interface_sofia}
\end{figure} 

\par Uma desvantagem desta interface é que ela pode não ser tão intuitiva aos usuários, que deverão levar algum tempo para se acostumar, principalmente aqueles que procuram por referências visuais dos componentes eletrônicos, como leds, \textit{protoboards}, etc. Apesar disso, um botão de ajuda foi adicionado no aplicativo, levando o usuário à pagina do projeto onde ele poderá entender o funcionamento do simulador.

\par Além disso, o tamanho da tela é reduzido, de forma que a inserção de muitos elementos pode prejudicar a experiência do usuário em termos de visualização dos resultados, já que apenas parte das entradas/saídas estarão visíveis (sem contar o possível uso do monitor serial).

\par O simulador \textit{BoardMicro - AVR Simulator}, assim como no projeto SOFIA, também utiliza uma representação abstrata do sistema ser simulado, como mostra a figura~\ref{fig:interface_BM_AVR}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.12]{./Resources/interface_BM_AVR}
	\caption{Tela principal do simulador \textit{BoardMicro - AVR Simulator}.} 
	Fonte: Autor
	\label{fig:interface_BM_AVR}
\end{figure} 

\par Na tela principal, apenas estão presentes a visualização de uma tela TFT na parte superior e dos PORTs de B a F (de cima para baixo). Na figura~\ref{fig:interface_BM_AVR}, a parte destacada em verde é o PORTC7, onde está ligado o led interno do Arduino Esplora.

\par Não há botões nem outras telas no aplicativo e toda a navegação é feita por toques. Esta característica torna o sistema bastante difícil de se utilizar, principalmente por não haver uma ajuda indicando quais são as ações possíveis. Este simulador possui ainda uma versão \textit{web}, com uma interface ligeiramente diferente, com mais indicações, como mostra a figura~\ref{fig:interface_BM_AVR_web}, o que facilita seu uso.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.75\textwidth]{./Resources/interface_BM_AVR_web}
	\caption{Tela principal do simulador \textit{BoardMicro - AVR Simulator}, versão para \textit{web}.} 
	Fonte: Autor
	\label{fig:interface_BM_AVR_web}
\end{figure} 

\par Esta escolha de interface se justifica por seu alvo ser o Arduino Esplora, que possui a forma de um \textit{joystick} e pode ser conectado à um display externo (internamente, a tela TFT mostrada na parte superior está interligada nos pinos de comunicação SPI do ATmega32U4 para estabelecer esta conexão). Mesmo assim, a falta completa de informações/indicações para o usuário dificultam o entendimento do sistema, forçando o usuário a estudar um material externo antes de poder utilizá-lo.

\par Partindo para o \textit{AndMCU}, este possui uma interface que lembra um kit de desenvolvimento PIC, mostrando inclusive o microcontrolador PIC18F458 (apesar do projeto funcionar com códigos assembly do microcontrolador 68705 da Motorola). A interface deste simulador é mostrada na figura~\ref{fig:interface_AndMCU}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{./Resources/interface_AndMCU}
	\caption{Tela principal do simulador \textit{AndMCU}.} 
	Fonte: Autor
	\label{fig:interface_AndMCU}
\end{figure} 

\par O kit apresentado conta com um display LCD de 16 caracteres, 6 displays de 7 segmentos, 2 barras gráficas com 8 leds cada, 2 \textit{DIP Switchs} de 8 vias e um teclado numérico. Além disso, existe um botão azul do lado superior esquerdo para interrupções externas, um botão vermelho para \textit{reset} manual no canto inferior esquerdo e um led de status no canto superior direito. Também, o sistema utiliza o sensor de luminosidade do \textit{smartphone} como entrada analógica e a documentação do projeto menciona ainda um piezo \textit{buffer}~\cite{AndMCU}.

\par Também aqui não há menus de ajuda ou qualquer instrução de uso no aplicativo. Na verdade, uma vez escolhido o código a ser executado, não há mais nada a se fazer no simulador a não ser trabalhar em cima da simulação atual. A troca de arquivos para simulação exige sair do aplicativo e iniciá-lo novamente.

\par Apesar disso, o \textit{AndMCU} apresenta um visual compacto, com boa disposição dos elementos na tela e com diversos recursos que devem ser facilmente reconhecidos por usuários já experientes com microcontroladores e eletrônica. O \textit{hardware} integrado dá a possibilidade ao usuário testar os programas mais comuns e mesmo alguns mais avançados.

\par Por fim, o \textit{Arduino Simulator Mini Free} também prefere um visual mais realista do \textit{hardware}, como mostra a figura~\ref{fig:interface_ASMF}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.15,angle=90]{./Resources/interface_AMSF}
	\caption{Tela principal do simulador \textit{Arduino Simulator Mini Free}.} 
	Fonte: Autor
	\label{fig:interface_ASMF}
\end{figure} 

\par Durante a simulação, o circuito é alterado no \textit{protoboard} de forma a fornecer o \textit{hardware} adequado para simular o código. A figura~\ref{fig:interface_ASMF_blink} mostra a interface para simulação do projeto \textit{Blink}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.15,angle=90]{./Resources/interface_AMSF_blink}
	\caption{Tela de simulação do projeto \textit{Blink}. O monitor serial no canto inferior direito pode ser escondido por meio do botão "\textit{Console}".} 
	Fonte: Autor
	\label{fig:interface_ASMF_blink}
\end{figure} 

\par Também para a visualização do código, o simulador busca uma interface que lembra a IDE do Arduino, como mostra a figura~\ref{fig:interface_ASMF_IDE}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.15,angle=90]{./Resources/interface_AMSF_IDE}
	\caption{Tela edição do código fonte a ser simulado.} 
	Fonte: Autor
	\label{fig:interface_ASMF_IDE}
\end{figure} 

\par O realismo buscado pelo \textit{Arduino Simulator Mini Free} pode ajudar o usuário que deseja, além de realizar a simulação, fazer a montagem posterior do circuito, já que o simulador mostra todo o esquemático necessário para executar o projeto.

\par Além disso, o \textit{design} proposto minimiza as dúvidas quanto ao seu uso. Ainda que não haja instruções, os elementos utilizados são bem conhecidos daqueles que já utilizam a IDE do Arduino, os botões possuem identificadores bastante claros quanto sua função, etc., de modo que, muito provavelmente, apenas um usuário iniciante pode vir a ter alguma dificuldade em utilizar este aplicativo.

\subsection{Funcionalidades oferecidas}

\par Cada aplicativo oferece um conjunto de funcionalidades e possibilidades de uso diferentes para o usuário.

\par O projeto SOFIA é focado na simulação do Arduino Uno e procura fornecer ao usuário um conjunto amplo de ferramentas para que se possa, além de simular o funcionamento do código, obter informações a respeito de sua execução. Desta forma, o sistema oferece a possibilidade de medição de frequência, \textit{duty cicle}, memória, além de permitir a configuração manual de uma referência externa de tensão para o conversor A/D. Também, o monitor serial integrado dá ao usuário uma maior possibilidade na depuração do código, permitindo o envio de mensagens de dentro do código para visualização externa.
\par Além disso, o projeto SOFIA busca ser um simulador genérico, permitindo que o usuário entre com qualquer código hexadecimal gerado, independente de sua fonte, apesar de recomendar o uso da IDE do Arduino modificada para o projeto, apenas por facilidade.
\par O usuário também é livre para testar diversas possibilidades de ligação entre entradas e saídas, podendo mesmo interligar múltiplas entradas em um mesmo pino; ligar uma entrada analógica em um pino digital e ver o efeito que níveis indefinidos de tensão podem gerar; conta com aviso em caso de curto-circuito, etc. A ideia principal é que, apesar de ser um simulador, as possibilidades de uso se aproximem do que o usuário encontrará em uma montagem eletrônica.

\par Já o projeto \textit{BoardMicro - AVR Simulator} é mais focado no uso do display TFT, fazendo com que o usuário explore este recurso para obter resultados de sua simulação, já que a visualização dos PORTs pode não ser o suficiente para obter informações.

\par Para interação com a simulação, o simulador utiliza a leitura do acelerômetro do \textit{smartphone} como entrada analógica e permite também o envio de comandos do GDB (apesar desta opção parecer não funcionar no aplicativo). A versão \textit{web} permite ainda a medição de parâmetros como o estado dos registradores, pilha, SDRAM e a velocidade do sistema, também permitindo controlar a velocidade de simulação.

\par Como dito anteriormente, o aplicativo não possui botões ou menus e a navegação por toques não é clara, mas é por meio dela é possível abrir o menu para carregar um código hexadecimal e acessar o \textit{prompt} do GDB. Um programa a ser simulado pode tanto ser escolhido de um banco de exemplos (com 4 códigos disponíveis) ou carregados pelo usuário a partir de seu repositório do \textit{Dropbox}.

\par O \textit{AndMCU} fornece um kit de desenvolvimento ao usuário e as possibilidades de interação com o aplicativo não vai muito além das possibilidades deste hardware virtual (com exceção para o uso do sensor de luminosidade do \textit{smartphone} para entrada analógica). A única interação do usuário externo à este kit é na escolha do código a ser simulado ao iniciar o aplicativo.

\par Apesar disso, sistema permite que diversas configurações sejam feitas no código em \textit{assembly} que será simulado. Entre as possibilidades estão o controle de velocidade de simulação, modo de simulação passo-a-passo, desabilitar os \textit{DIP Switches}, escrever conteúdo da memória em arquivo, entre outras possibilidades descritas na documentação.

\par O sistema fornece, assim como o \textit\{BoardMicro - AVR Simulator\}, um banco contendo 10 exemplos já codificados e um arquivo \textit{template} para servir de base para novos códigos. O usuário que desejar simular um código diferente deve adicioná-lo na pasta \url{/sdcard/AndMCU}.

\par E finalmente, o \textit{Arduino Simulator Mini Free} se mostrou o mais limitado em temos de funcionalidade. O simulador fornece 5 códigos exemplo para o usuário, que pode realizar modificações apenas em determinados campos, como alterar o pino de saída, tempo de \textit{delay} e mensagem do display LCD, não sendo possível criar um código próprio para a simulação. 
\par O usuário também não pode fornecer dados de entrada durante a simulação, podendo apenas visualizar o funcionamento do circuito. Isso acaba invalidando um dos códigos exemplo, que requer uma entrada analógica em um circuito utilizando LDR.
\par O \textit{Arduino Simulator Mini Free} possui duas outras versões pagas na \textit{Amazon Store}, com diferentes projetos e a possibilidade de edição do circuito eletrônico em uma delas.

\subsection{Requisitos do sistema e consumo de recursos}

\subsubsection{Sistema Operacional}

\par Todos os aplicativos suportam o sistema Android, com o \textit{Arduino Simulator Mini Free} disponível também para IOs (sob os nomes \textit{Arduino Simulator 2X - Learn and DIY Safely} e \textit{Arduino Simulator - Full Pack 2x}). A tabela~\ref{tab:comp_plataforma} indica qual a versão mínima do Android é requerida por cada aplicativo. Este valor foi obtido a partir da descrição do aplicativo nas lojas \textit{Play Store} e \textit{Amazon Store}.

\begin{table}[h]
	\centering
	\caption{Versão do Android requerida por cada aplicativo.}
	\label{tab:comp_plataforma}
	\begin{tabular}{|c|c|}
		\hline
		\textbf{Aplicativo} & \textbf{Versão do mínima} \\ \hline
		Arduino Simulator Mini Free & 2.2 \\ \hline
		MCU Prototype Board Simulator & 2.3.3 \\ \hline
		BoardMicro - AVR Simulator & 4.0 \\ \hline		
		SOFIA & 5.0 \\ \hline
	\end{tabular}
\end{table}

\par Ao criar um projeto no Android Studio, pode-se verificar qual a distribuição de usuários por versão do Android. A figura~\ref{fig:dist_android} apresenta esta distribuição e por ela, pode-se observar que, com exceção da SOFIA, todos os simuladores podem ser executados em 100\% dos dispositivos Android ativos no momento.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.45\textwidth]{./Resources/distrib_android}
	\caption{Distribuição acumulada de usuários Android. Como destacado, o simulador SOFIA poderá atingir pouco mais de 70\% dos dispositivos Android.} 
	Fonte: Android Studio
	\label{fig:dist_android}
\end{figure}

\subsubsection{Tamanho}

\par O gráfico mostrado na figura~\ref{fig:comp_tamanho} mostra o tamanho do arquivo APK para cada aplicativo.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/tamanho_apk}
	\caption{Tamanho do APK para cada aplicativo.} 
	Fonte: Autor
	\label{fig:comp_tamanho}
\end{figure} 

\par Pode-se observar que o \textit{Arduino Simulator Mini Free} possui um tamanho muito superior aos demais aplicativos, um resultado inesperado uma vez que a versão \textit{Full Pack} deste aplicativo possui um tamanho de 9MB.

\subsubsection{Uso de CPU}

\subsubsection{Uso de Memória}

\subsection{Documentação}

\subsection{Disponibilidade}

\section{Código e documentação}

\par O código fonte do projeto foi disponibilizado em um repositório \textit{on-line} no Github sob a licença Apache 2.0. As modificações feitas na IDE do Arduino também estão disponíveis na internet sob a mesma licença.

\begin{itemize}
\item \textbf{Projeto SOFIA:} \url{https://github.com/kollinslima/ProjectSOFIA}

\item \textbf{Arduino IDE:} \url{https://github.com/kollinslima/Arduino/tree/android}
\end{itemize}

\par Além do código, foi escrita uma documentação referente ao projeto no \href{https://www.gitbook.com}{\textit{Gitbook}}, que pode ser acessada a partir do repositório do projeto ou no menu "\textit{About}" do aplicativo.

\begin{itemize}
\item \textbf{Documentação:} \url{https://project-sofia.gitbook.io/project/}
\end{itemize}