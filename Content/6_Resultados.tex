\chapter{Resultados e Discussões}
\label{Resultados}

\par Nesta seção, serão apresentados os resultados obtidos com as modificações da IDE do Arduino e com o simulador para Android, bem como algumas métricas de \textit{software} obtidas para o simulador e algumas comparações feitas com aplicativos semelhantes ao desenvolvido neste trabalho.

\section{Arduino IDE}

\par A figura~\ref{fig:ide_modificada} mostra como ficou a IDE do Arduino após a introdução do botão "Android".

 \begin{figure}[h]
	\centering
	\includegraphics[width=0.6\textwidth]{./Resources/android_button}
	\caption{Localização do botão "Android" (Selecionado) na IDE} 
	Fonte: Autor
	\label{fig:ide_modificada}
\end{figure}

\par Ao pressionar o botão "Android", o processo de compilação se inicia e, em caso de sucesso, é exibida a janela para a seleção do dispositivo Android conectado ao PC, como mostrado na figura~\ref{fig:selecionar_dispositivo}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/device_selector}
	\caption{Seletor de dispositivos} 
	Fonte: Autor
	\label{fig:selecionar_dispositivo}
\end{figure}

\hfill
\par Ao selecionar o dispositivo, o usuário pode ativar a opção "\textit{Set as default device}". Isso fará com que a opção escolhida seja salva e não exibirá o seletor de dispositivos nas próximas compilações.
\par Se tudo ocorreu como o esperado, o usuário deve ver a mensagem de cópia no \textit{console} abaixo do editor, conforme mostra a figura~\ref{fig:console_sucesso}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/copy_success}
	\caption{Cópia do arquivo realizada com sucesso para o \textit{smartphone}} 
	Fonte: Autor
	\label{fig:console_sucesso}
\end{figure}

\section{Simulador}
\label{resultado_sofia}

\par Ao abrir o simulador, o usuário é recebido com uma \textit{Splash Screen}, mostrada na figura~\ref{fig:splash_screen}, enquanto o banco de dados é carregado para a memória principal, e posteriormente, o usuário é redirecionado para a tela inicial do simulador, mostrada na figura~\ref{fig:tela_inicial}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.25\textwidth]{./Resources/splash_screen}
	\caption{\textit{Splash Screen} exibida ao abrir o simulador} 
	Fonte: Autor
	\label{fig:splash_screen}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.45\textwidth]{./Resources/tela_inicial}
	\caption{Tela inicial do simulador} 
	Fonte: Autor
	\label{fig:tela_inicial}
\end{figure}

\par Na parte superior do simulador se concentram as opções para que o usuário comece a utilizar o sistema, bem como informações sobre o estado da simulação. Nesta \textit{toolbar}, o usuário tem acesso às seguintes opções/informações:

\begin{enumerate}
\item \textbf{Modelo simulado}: Mostra qual placa de Arduino está sendo utilizada para a simulação.
\item \textbf{Botão \textit{Reset}}: Permite o \textit{reset} manual do sistema.
\item \textbf{Adicionar Entrada/Saída}: Permite adicionar uma entrada/saída digital ou uma entrada analógica, bem como um monitor serial.
\item \textbf{Outras opções}: Contém funções adicionais para importar código do \textit{smartphone}, mapa de memória, configuração de tensão de referência (para o conversor A/D), remover todas as entradas/saídas, ajuda e acesso à informações do projeto.
\end{enumerate}

\par Além disso, o usuário pode visualizar:

\begin{enumerate}
	\setcounter{enumi}{4}
\item \textbf{Tempo simulado}: Exibe tempo simulado do sistema, baseado no cristal de 16MHz e atualizado a cada pulso de \textit{clock} interno do sistema.
\item \textbf{Status}: Mostra o \textit{status} da simulação.
\item \textbf{Área de Trabalho}: Onde serão dispostos os elementos de entrada e saída.
\end{enumerate}

\par Caso não seja encontrado um arquivo hexadecimal ou ocorra alguma falha em sua abertura, o usuário deve ver uma mensagem na barra de \textit{status} informando o problema, como mostrado na figura~\ref{fig:hex_file_not_found}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.35\textwidth]{./Resources/hex_file_not_found}
	\caption{Falha ao abrir arquivo hexadecimal} 
	Fonte: Autor
	\label{fig:hex_file_not_found}
\end{figure}

\subsection{Interação com o sistema}

\par O usuário interage com o sistema por meio de entradas e saídas no simulador. Uma saída digital é mostrada na figura~\ref{fig:saida_digital}. No lado esquerdo é possível selecionar o pino no qual a saída estará conectada e do lado direito é mostrado o estado do pino. Por padrão, o pino 13 é selecionado, uma vez que este é o pino onde o LED interno está conectado no Arduino UNO. A figura~\ref{fig:saida_digital} mostra os três estados possíveis para uma saída no simulador.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.55\textwidth]{./Resources/outputs}
	\caption{Saídas digitais do simulador} 
	Fonte: Autor
	\label{fig:saida_digital}
\end{figure}

\vfill
\par Uma entrada pode ser digital ou analógica. Uma entrada digital é mostrada na figura~\ref{fig:entrada_digital}. Pode-se observar que existem 4 elementos em uma entrada digital, são eles (da esquerda para a direita):

\begin{figure}[h]
	\centering
	\includegraphics[width=0.60\textwidth]{./Resources/inputs}
	\caption{Entradas digitais do simulador} 
	Fonte: Autor
	\label{fig:entrada_digital}
\end{figure}

\begin{itemize}
\item \textbf{Botão}: por onde o usuário envia sinais ao o sistema.
\item \textbf{Seletor de modo}: define a operação do botão, podendo ser:
	\begin{itemize}
	\item Push-GND: envia nível baixo se pressionado, indefinido caso contrário (é a opção padrão).
	\item Push-VDD: envia nível alto se pressionado, indefinido caso contrário.
	\item Pull-Up: envia nível baixo se pressionado, alto caso contrário.
	\item Pull-Down: envia nível alto se pressionado, baixo caso contrário.
	\item Toggle: alterna seu nível a cada toque no botão.
	\end{itemize}
\item \textbf{Seletor de pino}: define para qual pino do Arduino o sinal deve ser enviado.
\item \textbf{Saída do sinal}: mostra o que está sendo enviado para o pino selecionado
\end{itemize}

\par Por padrão, nenhum pino está selecionado. Isso garante que não haverá um curto-circuito ao adicionar uma entrada. Em caso de curto-circuito, é exibida uma mensagem na barra de status (como mostra a figura~\ref{fig:curto-circuito}) e a simulação para, podendo ser reiniciada manualmente assim que a condição de curto-circuito for removida.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.45\textwidth]{./Resources/short_circuit}
	\caption{Condição de cuito-circuito entre entradas} 
	Fonte: Autor
	\label{fig:curto-circuito}
\end{figure}

\par Uma entrada analógica é mostrada na figura~\ref{fig:entrada_analogica}. Ela possui um seletor de pino, uma barra deslizante e um voltímetro, indicando o valor de tensão enviado ao Arduino. Esta entrada permite ao usuário enviar valores de tensão entre 0V e 5V e assim como na entrada digital, nenhuma entrada está selecionada por padrão.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.45\textwidth]{./Resources/analog_input}
	\caption{Entradas analógicas do simulador} 
	Fonte: Autor
	\label{fig:entrada_analogica}
\end{figure}

\par Caso se queira remover uma entrada/saída, pode-se utilizar um toque longo na célula desejada e selecionar quais elementos serão removidos, como mostra a figura~\ref{fig:remocao}. Alternativamente, pode-se utilizar a opção "\textit{Clear I/O}" da \textit{toolbar} para remover todas as entradas e saídas.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.35\textwidth]{./Resources/remocao}
	\caption{Remoção manual de pinos de saída} 
	Fonte: Autor
	\label{fig:remocao}
\end{figure}

\subsection{Monitor Serial}

\par Outro modo de interação com o sistema é por meio do monitor serial, mostrado na figura~\ref{fig:monitor_serial}. Este monitor pode ser utilizado para receber ou enviar informações para a USART e ocupa o mesmo espaço reservado para as saídas digitais, ou seja, não é possível visualizar as saídas em conjunto com o monitor serial (é possível, no entanto, utilizá-lo simultaneamente com entradas). 

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.25\textwidth]{./Resources/serial_monitor_working}
	\caption{Monitor Serial} 
	Fonte: Autor
	\label{fig:monitor_serial}
\end{figure}

\par O monitor serial pode ser removido também com a opção "\textit{Clear I/O}" ou clicando no "x" na parte superior.

\subsection{Mapa de memória}

\par O recurso de mapa de memória é apresentado na figura~\ref{fig:mapa_memoria}. Este recurso permite ao usuário ver e acompanhar o estado de cada bit da memória de dados enquanto a simulação continua funcionando, bem como verificar qual o uso total de memória pelo sistema em bytes e em porcentagem. O estado dos bits não é atualizado automaticamente na tela, mas sim a cada 800ms, diminuindo o impacto na performance do simulador quando este recurso é aberto.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.20\textwidth]{./Resources/memory_map}
	\caption{Mapa de memória} 
	Fonte: Autor
	\label{fig:mapa_memoria}
\end{figure}

\par Toda a memória (2kB), somado aos registradores, podem ser visualizados com esta função. Para facilitar a busca por um endereço específico, os registradores foram nomeados e adicionou-se o recurso de busca, que pode ser acessado pelo ícone de lupa no canto superior direito. A figura~\ref{fig:mapa_memoria_busca} mostra a busca sendo utilizada para encontrar o registrador TCNTx.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.20\textwidth]{./Resources/memory_map_search}
	\caption{Recurso de busca do mapa de memória} 
	Fonte: Autor
	\label{fig:mapa_memoria_busca}
\end{figure}

\subsection{Referência externa de tensão}

\par Outro recurso que foi inserido no simulador foi a configuração da referência externa de tensão para conversão analógica. Em \textit{hardware}, esta referência é aplicada no pino AREF e utilizada como base para conversão. No simulador, pode-se utilizar o menu "\textit{AREF Config}" para simular esta função. A figura~\ref{fig:aref_config} mostra a tela de configuração exibida.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.25\textwidth]{./Resources/AREF_config}
	\caption{Configuração de tensão externa aplicada ao pino AREF, usada como base para conversão A/D} 
	Fonte: Autor
	\label{fig:aref_config}
\end{figure}

\par Por padrão, o valor configurado é de 5V (como mostra a figura~\ref{fig:aref_config}). Este valor pode ser alterado para qualquer valor real que esteja dentro das epecificações mínimas e máximas apresentadas na folha de dados do ATmega328P (Mínimo: 1V, Máximo: 5V).

\subsection{Medição de frequência}

\par Caso a frequência de oscilação de um pino de saída seja muito alta, o simulador não será capaz de exibir esta intermitência corretamente devido a limitações de velocidade da atualização da tela do Android (máximo 60fps). Nestes casos, pode-se utilizar o recurso de frequencímetro integrado ao simulador para verificar a qual frequência a saída está alterando seu estado. (Na verdade, pode-se utilizar o frequencímetro em qualquer ocasião, este é apenas um caso onde seu uso se faz absolutamente necessário para depuração.)

\par Para medir frequência em um pino de saída, basta pressionar a saída desejada com um toque longo e selecionar frequencímetro (figura~\ref{fig:frequencimetro_icone}). Os valores de frequência e \textit{duty cicle} aparecerão na célula de saída, como mostra a figura~\ref{fig:frequencimetro}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/frequency_meter_icon}
	\caption{Ícone do frequencímetro} 
	Fonte: Autor
	\label{fig:frequencimetro_icone}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/frequency_meter}
	\caption{Frequencímetro em funcionamento} 
	Fonte: Autor
	\label{fig:frequencimetro}
\end{figure}

\par A medição de frequência implementada se mostrou bastante precisa quando comparada com as medições reais de frequência. Para realizar os testes, foram utilizados os projetos \textit{Blink} e \textit{Timer1}, apresentados nos apêndices~\ref{apendice_blink} e~\ref{apendice_timer} respectivamente. O projeto \textit{Blink} foi utilizado ora com a função \textit{delay}, ora com função \textit{delayMicroseconds}, desta forma podendo obter diferentes valores de frequência gerados por diferentes métodos, enquanto o projeto \textit{Timer1} foi configurado com diferentes valores em TCNT1 para as diferentes configurações de frequência e \textit{duty cycle}. As tabelas~\ref{tab:comparacao_frequencia} e~\ref{tab:comparacao_duty} apresentam os valores medidos de frequência obtidos com o simulador e com o osciloscópio ligado ao Arduino, bem como o erro relativo de cada medição comparado com o valor teórico esperado. 

\par Como pode ser observado, o simulador e o Arduino se comportam de maneira semelhantes tanto na medição de frequência quanto nas relativas ao \textit{duty cicle}, apresentando um erro relativo alto quando se trabalha com altas frequências. 

\par Com isso, conclui-se que o frequencímetro incluso no simulador fornece medições satisfatórias, principalmente se a aplicação desenvolvida não tiver grandes exigências quanto à estes parâmetros. Notou-se apenas uma certa instabilidade nos valores quando as medições eram feitas em altas frequências, mas nada crítico ao ponto de não permitir o uso e a leitura das grandezas.

\begin{table}[p]
	\centering
	\caption{Comparação das medições de frequência (\textit{duty cycle: 50\%}). Foram coletadas 110 amostras em cada frequência medida}
	\label{tab:comparacao_frequencia}
	\begin{tabular}{|c|c|c|c|c|c|c|c|}
		\hline
		\multirow{3}{*}{\textbf{Função}} & \multirow{3}{*}{\textbf{Período}} & \multicolumn{4}{c|}{\textbf{Frequência (Hz)}}                                             & \multicolumn{2}{c|}{\textbf{Erro (\%)}}                 \\ \cline{3-8} 
		&  & \multicolumn{2}{c|}{SOFIA} & \multicolumn{2}{c|}{Arduino} & \multirow{2}{*}{SOFIA} & \multirow{2}{*}{Arduino} \\ \cline{3-6}
		&\textbf{(Teórico)}  & Média & D. Padrão & Média & D. Padrão           &                   &                   \\ \hline
		\multirow{3}{*}{\textit{\small{delayMicroseconds}}} 
		& 2 $\mu$s & 107.062 & 37.946 & 133.254 & 4,93          
		& 78,59 & 73,35 \\ \cline{2-8} 
		& 0,5 ms & 1.967 & 12,04 & 1.968 & 11,97           
		& 1,63 & 1,58  \\ \cline{2-8} 
		& 1 ms & 989,16 & 0,98 & 988,36 & 0,03    
		& 1,08 & 1,16                   \\ \hline
		\multirow{3}{*}{\textit{\small{delay}}}
		& 2 ms & 495,71 & 0,55 & 495,44 & 9,47
		& 0,86 & 0,91 \\ \cline{2-8} 
		& 4 ms & 248,96 & 0,19 & 248,64 & 0,21 
		& 0,41 & 0,55 \\ \cline{2-8} 
		& 8 ms & 125 & 0 & 124,59 & 0,03 
		& 0 & 0,32 \\ \hline
		\multirow{4}{*}{\textit{\small{Timer 1}}}
		& 125 ns & 33.991 & 3.187 & 39.778 & 1,01          
		& 99,58  & 99,5                  \\ \cline{2-8} 
		& 2,048 ms & 484 & 0 & 483,52 & 0,16   
		& 0,88 & 0,97 \\ \cline{2-8} 
		& 4,129 ms & 242,99 & 0,09 & 242,88 & 0,06
		& 0,33 & 0,28  \\ \cline{2-8} 
		& 8,192 ms & 122 & 0 & 121,72 & 0,01
		& 0,06 & 0,28                  \\ \hline
	\end{tabular}
\end{table}

\begin{table}[p]
	\centering
	\caption{Comparação das medições de \textit{duty cicle} (projeto: \textit{Timer1}, frequência: 488Hz). Foram coletadas 111 amostras para cada valor de \textit{duty cycle} medido}
	\label{tab:comparacao_duty}
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		\multicolumn{5}{|c|}{\textbf{Duty Cycle (\%)}}        & \multicolumn{2}{c|}{\textbf{Erro (\%)}}                 \\ \hline
		\multirow{2}{*}{Teórico} & \multicolumn{2}{c|}{SOFIA} & \multicolumn{2}{c|}{Arduino} & \multirow{2}{*}{SOFIA} & \multirow{2}{*}{Arduino} \\ \cline{2-5}
		& Média & D. Padrão & Média & D. Padrão &                   &                   \\ \hline
%		1  & 2  & 0 & 2,11  & 0,002 & 100 & 111             \\ \hline
		25 & 26 & 0 & 25,58 & 0,034 & 4   & 2,31            \\ \hline
		50 & 50 & 0 & 50,01 & 0,012 & 0   & 0,01            \\ \hline
		75 & 74 & 0 & 74,43 & 0,003 & 1,33& 0,76             \\ \hline
		99 & 98 & 0 & 97,90 & 0,002 & 1,01& 1,11             \\ \hline
	\end{tabular}
\end{table}

\section{Métricas de \textit{Software}}

\subsection{Análise Estática}

\par Com o uso do SonarQube, foi realizada a analise estática do código com o objetivo principal de identificar e corrigir problemas relacionados à segurança, vulnerabilidades e manutenibilidade. O SonarQube fornece diversas métricas a respeito do projeto, além de classificar a qualidade do \textit{software} com notas variando de A (melhor qualidade) a E (pior qualidade).
\par A primeira métrica relevante que a ferramenta fornece é uma medida de confiabilidade do sistema, baseada no número de \textit{bugs}. A figura~\ref{fig:confiabilidade} mostra um gráfico relacionando cada classe do projeto com a quantidade de \textit{bugs} encontrados (tempo para correção dos defeitos). Pode-se observar que uma classe se destaca pela sua quantidade de \textit{bugs}, esta classe é a \textit{DataMemory\_ATmega328P}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/confiabilidade}
	\caption{Gráfico linhas de código x esforço para resolução dos \textit{bugs}} 
	Fonte: Autor
	\label{fig:confiabilidade}
\end{figure}
 
\par É importante ressaltar que, por ser uma ferramenta de análise estática, muitos problemas apontados podem não se aplicar ao projeto ou ser falsos positivos. Em se tratando de \textit{bugs}, dos problemas que não foram resolvidos sobraram apenas \textit{bugs} relacionados ao tratamento de exceções (que está sendo feito com o uso de \textit{Logs}, no Android Studio) e à conversão (\textit{cast}) de valores (os casos de teste criados com o JUnit4 estão testando estas conversões). Devido à estes problemas o sistema receberia classificação C em termos de confiabilidade, no entanto foi atribuída a nota E devido à um \textit{bug} identificado na classe \textit{DataBaseHelper} relacionado à abertura e fechamento do banco de dados (apesar deste ter sido corrigido conforme a sugestão proposta).

\par Outra métrica fornecida diz respeito à segurança do sistema e se baseia na quantidade de vulnerabilidades encontradas. A figura~\ref{fig:seguranca} apresenta um gráfico relacionando cada classe do projeto com a quantidade de vulnerabilidades (tempo para correção dos defeitos). Novamente, observa-se uma classe em destaque, esta é a \textit{OutputFragment\_Atmega328P}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/seguranca}
	\caption{Gráfico linhas de código x esforço para resolução das vulnerabilidades} 
	Fonte: Autor
	\label{fig:seguranca}
\end{figure} 

\par Em termos de vulnerabilidades, o sistema apresenta melhores resultados em comparação aos \textit{bugs}. Das que não foram resolvidas, sobraram apenas vulnerabilidades relacionadas à manipulação de variáveis estáticas. Muitas destas, no entanto, são variáveis privadas, de forma que não existem grandes problemas relacionado com o acesso delas por classes externas (como foi apontado pela ferramenta). O sistema foi classificado com o \textit{ranking} B para segurança.

\par A próxima métrica obtida diz respeito a manutenibilidade do código. Esta medida é feita com base na compexidade cognitiva dos métodos e quanto ao uso devido/indevido de padrões de codificação (esses são chamados \textit{Code Smells}). A figura~\ref{fig:manutencao} apresenta um gráfico relacionando cada classe do projeto com a quantidade de \textit{Code Smells} encontrados (tempo para correção dos defeitos). A classe com maior número de problemas para essa métrica é a \textit{Timer1\_ATmega328P}.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{./Resources/manutencao}
	\caption{Gráfico linhas de código x esforço para resolução dos \textit{Code Smells}} 
	Fonte: Autor
	\label{fig:manutencao}
\end{figure} 

\par Muitos dos problemas apontados nesta categoria são de menor importância, tais como remover linhas comentadas, mudar nomes de variáveis, etc. Os problemas de maior importância são os de complexidade cognitiva, que indicam que um método está muito grande, tornando-o de difícil compreensão. No entanto, alguns destes métodos não podem ser refatorados facilmente, já que comprometeria a arquitetura geral do projeto.
\par Outro problema apontado quanto à manutenibilidade foi a quantidade de níveis de herança que algumas classes possuem, excedendo o limite de 5 níveis. Não há muito o que fazer nestes casos, já que estas classes não herdam de nenhum código desenvolvido, mas de classes do próprio sistema Android (como é o caso da classe \textit{AppCompatActivity}). Este foi o principal motivo para que o sistema fosse classificado com o \textit{ranking} C para manutenibilidade.

\par Também foi obtida uma métrica de código duplicado. A figura~\ref{fig:duplicacao} apresenta um gráfico relacionando cada classe do projeto com a quantidade de linhas de código duplicadas. 

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/duplicacao}
	\caption{Gráfico linhas de código x linhas de código duplicadas.} 
	Fonte: Autor
	\label{fig:duplicacao}
\end{figure} 

\par As classes com maior número de código duplicado são as classes referentes aos temporizadores (o \textit{Timer1} é a classe em destaque na figura~\ref{fig:duplicacao}) e a CPU. Os modos de operação dos \textit{Timers} se assemelham em muitos aspectos, no entanto, escrever um único método para gerenciar todos estes modos certamente o tornaria grande e complexo (gerando um problema na métrica de complexidade cognitiva) e portanto, foram criados diferentes métodos, cada um com pequenas variações, de forma a atender o modo de operação configurado. Um problema semelhante ocorre com a CPU, já que várias instruções realizam a leitura e a escrita dos valores na memória de maneira idêntica, mas suas operações são diferentes de modo que também não é possível unir códigos de diferentes instruções.

\par A última métrica importante de ser mencionada é a de complexidade ciclomática. Esta é uma métrica interessante pois diz qual é o número mínimo de casos de teste necessários para que eles cubram todo o projeto (cobertura de linhas). O valor obtido para complexidade ciclomática foi de 1.969.

\subsection{Cobertura}

\par Foram criados teste de unidade para todos os principais módulos do projeto (CPU, memórias de dado e de programa, conversor A/D, temporizadores, USART e módulo de interrupção), totalizando 808 casos de teste. O foco dos testes foi a cobertura de linhas e condicionais e análise de valor limite, este último aplicado principalmente aos testes da CPU.

\par A cobertura dos testes criado foi medida tanto com a ferramenta interna do Android Studio quanto com o \textit{plugin} JaCoCo (integrado ao SonarQube). Houve uma diferença de 10\% nas duas medidas de cobertura por estas ferramentas, com o Android Studio registrando 59\% de cobertura e o JaCoCo 49\%, como mostram as figuras~\ref{fig:cobertura_android_studio} e~\ref{fig:cobertura_jacoco}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.65\textwidth]{./Resources/cobertura_android_studio}
	\caption{Medida de cobertura do projeto obtida com o  Android Studio} 
	Fonte: Autor
	\label{fig:cobertura_android_studio}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/cobertura_jacoco}
	\caption{Medida de cobertura do projeto obtida com o JaCoCo} 
	Fonte: Autor
	\label{fig:cobertura_jacoco}
\end{figure}

\par A cobertura dos testes por módulo é apresentada nas figuras~\ref{fig:cobertura_modulo_android_studio} e~\ref{fig:cobertura_modulo_jacoco}. A partir destes dois gráficos apresentados, pode-se dizer que a medição realizada pelo Android Studio se mostra mais exata ao esperado, já que as medidas do JaCoCo indicam uma cobertura de 0\% para a USART, quando existem 7 casos de teste para este módulo, e 100\% para módulo de E/S, quando não foi escrito nenhum caso de teste para este módulo, por este ser mais dedicado à operações com interface gráfica.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{./Resources/cobertura_modulo_android_studio}
	\caption{Cobertura por módulo (Android Studio)} 
	Fonte: Autor
	\label{fig:cobertura_modulo_android_studio}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{./Resources/cobertura_modulo_jacoco}
	\caption{Cobertura por módulo (JaCoCo)} 
	Fonte: Autor
	\label{fig:cobertura_modulo_jacoco}
\end{figure}

\par Além dos testes automatizados, foram realizados testes manuais das funcionalidades desenvolvidas. Todos os códigos testados podem ser vistos na seção de apêndice deste trabalho.

\section{\textit{Profiling}}
\label{profiling}

\par Foi utilizada a ferramenta de \textit{profilling} do próprio Android Studio para avaliar o consumo de recursos do aplicativo e tentar identificar pontos de otimização. O projeto \textit{Blink} (apêndice~\ref{apendice_blink}), foi utilizado no simulador durante a execução do \textit{profilling}. 
\par O sistema foi avaliado quanto ao seu uso de CPU e memória, a figura~\ref{fig:profilling_geral} mostra o desempenho do sistema considerando estes dois fatores. Pode-se observar que o uso de CPU fica em torno de 25\%, enquanto que o uso de memória é de aproximadamente 30MB.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\textwidth]{./Resources/profilling_general}
	\caption{Uso de CPU e memória do aplicativo para o projeto \textit{Blink}} 
	Fonte: Autor
	\label{fig:profilling_geral}
\end{figure} 

\par Olhando especificamente para a CPU (utilizando a opção de gravação instrumentada para rastreamento de métodos), observou-se que muito do uso de CPU não está relacionado diretamente com as classes desenvolvidas, mas sim com chamadas à classes internas do Android. Do que foi desenvolvido, a classe \textit{UCModule\_View} se mostrou o principal ponto crítico, mais especificamente o método \textit{run}, que faz a atualização do tempo simulado na tela. A figura~\ref{fig:profilling_cpu} apresenta este resultado.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/profilling_cpu}
	\caption{Tempo de uso da CPU (medido em uma janela de 5 minutos)} 
	Fonte: Autor
	\label{fig:profilling_cpu}
\end{figure} 

\par Uma medida tomada quanto à este resultado foi atrasar a atualização do tempo simulado por um fator de 1024, ou seja, uma requisição de atualização da tela só é dada após 1024 passagens pelo método \textit{run}. O valor de 1024 foi obtido experimentalmente de modo a não prejudicar a fluidez da interface (valores maiores fazem com que o tempo simulado salte de um valor para outro, dando a impressão que o sistema está a ponto de travar).
\par Essa medida teve um impacto significativo no desempenho deste método, que passou de um uso de CPU em torno de 17\% para pouco menos de 0,5\% , como mostra a figura~\ref{fig:profilling_cpu_melhoria}.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{./Resources/profilling_cpu_melhoria}
	\caption{Tempo de uso da CPU após melhoria no método \textit{run} (medido em uma janela de 5 minutos)} 
	Fonte: Autor
	\label{fig:profilling_cpu_melhoria}
\end{figure} 

\hfil
\par Também foi feito um \textit{profilling} específico para o uso de memória. Os resultados são mostrados na figura~\ref{fig:profilling_memoria}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/profilling_memoria}
	\caption{Consumo de memória (medido em uma janela de 5 minutos)} 
	Fonte: Autor
	\label{fig:profilling_memoria}
\end{figure} 

\par O que se observa em termos de memória é que as estruturas de \textit{Enum}, utilizadas na CPU e nos temporizadores, foram as responsáveis por fazer com que estes módulos se destacassem no uso de memória. De certa forma, este resultado já era esperado uma vez que estas são estruturas estáticas, o que demanda um maior tamanho em memória e não são limpas pelo \textit{Garbage Collector} do Java.

\par Por outro lado, o uso de \textit{Enum} permitiu obter uma funcionalidade próxima aos ponteiros de função que se tem na linguagem C, recurso bastante útil para fazer a decodificação das instruções na CPU (bem como a seleção do \textit{prescaler} nos temporizadores). 

\par Como mencionado na seção~\ref{teoria_cpu}, manter a legibilidade do código durante a decodificação foi uma grande preocupação durante o desenvolvimento. O uso de memória é um preço a se pagar por essa facilidade obtida com a estrutura \textit{Enum}. Mesmo assim, o aplicativo não apresenta valores elevados de consumo de memória quando comparado com outros aplicativos semelhantes, como mostra a seção~\ref{sec:comparacao}.

\section{Comparação entre aplicativos}
\label{sec:comparacao}

\par Foram 3 os aplicativos selecionados para serem comparados com o projeto SOFIA, são eles:

\begin{itemize}
	\item \textit{Arduino Simulator Mini Free}
	\item \textit{BoardMicro - AVR Simulator} (aplicativo e \textit{web}).
	\item \textit{AndMCU} (ou \textit{MCU Prototype Board Simulator})
\end{itemize}

\par Os aplicativos não são exatamente uma alternativa uns dos outros, mas apresentam características semelhantes e um mesmo propósito, que é a simulação de um microcontrolador.

%\par Apesar de o aplicativo \textit{AndMCU} não estar diretamente relacionado com Arduino ou a arquitetura AVR, seu propósito é basicamente o mesmo do proposto que é proposto neste trabalho e portanto decidiu-se por analisá-lo também.

\par Para a realização dos testes, foi utilizado novamente o projeto \textit{Blink} do apêndice~\ref{apendice_blink} nos simuladores \textit{BoardMicro - AVR Simulator} e SOFIA. O aplicativo \textit{Arduino Simulator Mini Free} não permite a edição de códigos, mas possui o mesmo projeto disponível para simulação. Quanto ao \textit{AndMCU}, foi escrito um programa em \textit{assembly} mostrado no apêndice~\ref{apendice_blink_asm} para a poder testá-lo, já que este simulador se destina à outra plataforma. 

\subsection{Interface}

\par O primeiro ponto a ser comparado são as interfaces que cada aplicativo oferece para ao usuário.

\par O projeto SOFIA, como já foi mostrado na seção~\ref{resultado_sofia}, procura oferecer uma interface simples, sem fazer referência à componentes eletrônicos. Na tela principal, o usuário tem sempre a sua disposição botões para realizar todas as tarefas que desejar no aplicativo, seja inserir novos elementos, reiniciar a simulação ou acessar funções adicionais, tudo isso sem que seja necessário acessar novas telas. A figura~\ref{fig:interface_sofia} mostra a interface principal da SOFIA com algumas entradas e saídas.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.70]{./Resources/simulation_with_io}
	\caption{Tela principal do simulador SOFIA} 
	Fonte: Autor
	\label{fig:interface_sofia}
\end{figure} 

\par Uma desvantagem desta interface é que ela não é tão intuitiva aos usuários, que poderão levar algum tempo para se acostumar, principalmente aqueles que procuram por referências visuais dos componentes eletrônicos, como LEDs, \textit{protoboards}, etc. Por este motivo, um botão de ajuda foi adicionado no aplicativo para levar o usuário à página do projeto, onde ele terá todas as informações necessárias para o uso do simulador.

\par Além disso, o tamanho da tela é reduzido, de forma que a inserção de muitos elementos pode prejudicar a experiência do usuário em termos de visualização dos resultados, já que apenas parte das entradas/saídas estarão visíveis (sem contar o possível uso do monitor serial).

\par O simulador \textit{BoardMicro - AVR Simulator}, assim como no projeto SOFIA, também utiliza uma representação abstrata do sistema a ser simulado, como mostra a figura~\ref{fig:interface_BM_AVR}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.13]{./Resources/interface_BM_AVR}
	\caption{Tela principal do simulador \textit{BoardMicro - AVR Simulator}} 
	Fonte: Autor
	\label{fig:interface_BM_AVR}
\end{figure} 

\par Na tela principal, apenas estão presentes a visualização de uma tela TFT LCD na parte superior e dos PORTs de B a F (de cima para baixo). Na figura~\ref{fig:interface_BM_AVR}, a parte destacada em verde é o PORTC7, onde está ligado o LED interno do Arduino Esplora.

\par Não há botões nem outras telas no aplicativo e toda a navegação é feita por toques. Esta característica torna o sistema bastante difícil de se utilizar, principalmente por não haver uma ajuda indicando quais são as ações possíveis. Este simulador possui ainda uma versão \textit{web}, com uma interface ligeiramente diferente, com mais indicações, como mostra a figura~\ref{fig:interface_BM_AVR_web}, o que facilita seu uso.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{./Resources/interface_BM_AVR_web}
	\caption{Tela principal do simulador \textit{BoardMicro - AVR Simulator}, versão para \textit{web}} 
	Fonte: Autor
	\label{fig:interface_BM_AVR_web}
\end{figure} 

\par Esta escolha de interface se justifica uma vez que a plataforma alvo deste simulador é o Arduino Esplora, que possui a forma de um \textit{joystick} e pode ser conectado à um display externo (internamente, a tela TFT mostrada na parte superior está interligada nos pinos de comunicação SPI do ATmega32U4 para estabelecer esta conexão). Mesmo assim, a falta completa de informações/indicações para o usuário dificultam o entendimento do sistema, forçando o usuário a estudar o aplicativo por algum tempo antes de poder utilizá-lo.

\newpage

\par Partindo para o \textit{AndMCU}, este possui uma interface que lembra um kit de desenvolvimento PIC, mostrando inclusive o microcontrolador PIC18F458 (apesar do projeto funcionar com códigos assembly do microcontrolador 68705 da Motorola). A interface deste simulador é mostrada na figura~\ref{fig:interface_AndMCU}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.75]{./Resources/interface_AndMCU}
	\caption{Tela principal do simulador \textit{AndMCU}} 
	Fonte: Autor
	\label{fig:interface_AndMCU}
\end{figure} 

\par O kit apresentado conta com um display LCD de 16 caracteres, 6 displays de 7 segmentos, 2 barras gráficas com 8 LEDs cada, 2 \textit{DIP Switchs} de 8 vias e um teclado numérico. Além disso, existe um botão azul no canto superior esquerdo para interrupções externas, um botão vermelho para \textit{reset} manual no canto inferior esquerdo e um LED de status no canto superior direito. Também, o sistema utiliza o sensor de luminosidade do \textit{smartphone} como entrada analógica e a documentação do projeto menciona ainda um piezo \textit{buffer}~\cite{AndMCU}.

\par Este simulador também não conta com menus de ajuda ou qualquer instrução de uso no aplicativo. Na verdade, uma vez escolhido o código a ser executado, não há mais nada a se fazer no simulador a não ser trabalhar em cima da simulação atual. A troca de arquivos para simulação exige sair do aplicativo e iniciá-lo novamente.

\par Apesar disso, o \textit{AndMCU} apresenta um visual compacto, com boa disposição dos elementos na tela e com diversos recursos que devem ser facilmente reconhecidos por usuários já experientes com microcontroladores e eletrônica. O \textit{hardware} integrado dá a possibilidade para que o usuário possa testar os programas mais comuns e mesmo alguns mais avançados.

\par Por fim, o \textit{Arduino Simulator Mini Free} também prefere um visual mais realista do \textit{hardware}, como mostra a figura~\ref{fig:interface_ASMF}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.21,angle=90]{./Resources/interface_AMSF}
	\caption{Tela principal do simulador \textit{Arduino Simulator Mini Free}} 
	Fonte: Autor
	\label{fig:interface_ASMF}
\end{figure} 

\par Durante a simulação, o circuito é alterado no \textit{protoboard} de forma a fornecer o \textit{hardware} adequado para simular o código. A figura~\ref{fig:interface_ASMF_blink} mostra a interface para simulação do projeto \textit{Blink}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.21,angle=90]{./Resources/interface_AMSF_blink}
	\caption{Tela de simulação do projeto \textit{Blink}. O monitor serial no canto inferior direito pode ser escondido por meio do botão "\textit{Console}"} 
	Fonte: Autor
	\label{fig:interface_ASMF_blink}
\end{figure} 

\par Também para a visualização do código, o simulador busca uma interface que lembra a IDE do Arduino, como mostra a figura~\ref{fig:interface_ASMF_IDE}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{./Resources/ide_arduino_mini_free}
	\caption{Tela edição do código-fonte a ser simulado.} 
	Fonte: Autor
	\label{fig:interface_ASMF_IDE}
\end{figure} 

\par O realismo buscado pelo \textit{Arduino Simulator Mini Free} pode ajudar o usuário que deseja, além de realizar a simulação, fazer a montagem posterior do circuito, já que o simulador mostra todo o esquemático necessário para executar o projeto.

\par Além disso, o \textit{design} proposto minimiza as dúvidas quanto ao seu uso. Ainda que não haja instruções, os elementos utilizados são bem conhecidos daqueles que já utilizam a IDE do Arduino e os botões possuem identificadores bastante claros quanto sua função, de modo que, muito provavelmente, apenas um usuário iniciante pode vir a ter alguma dificuldade em utilizar este aplicativo.

\subsection{Funcionalidades oferecidas}

\par Cada aplicativo oferece um conjunto de funcionalidades e possibilidades de uso diferentes para o usuário.

\par O projeto SOFIA é focado na simulação do Arduino UNO e procura fornecer ao usuário um conjunto de ferramentas para que se possa, além de simular o funcionamento do código, obter informações a respeito de sua execução. Desta forma, o sistema oferece a possibilidade de medição de frequência, \textit{duty cicle}, memória, além de permitir a configuração manual de uma referência externa de tensão para o conversor A/D. Também, o monitor serial integrado dá ao usuário uma maior possibilidade na depuração do código, permitindo o envio de mensagens de dentro do código para visualização externa.
\par Além disso, o projeto SOFIA busca ser um simulador genérico, permitindo que o usuário entre com qualquer código hexadecimal gerado, independente de sua fonte. O usuário também é livre para testar diversas possibilidades de ligação entre entradas e saídas, podendo mesmo interligar múltiplas entradas em um mesmo pino; ligar uma entrada analógica em um pino digital e ver o efeito que níveis indefinidos de tensão podem gerar; conta com aviso em caso de curto-circuito, etc. A ideia principal é que, apesar de ser um simulador, as possibilidades de uso se aproximem do que o usuário encontrará em uma montagem eletrônica real.

\par Já o projeto \textit{BoardMicro - AVR Simulator} é mais focado no uso do display TFT, fazendo com que o usuário explore este recurso para obter resultados de sua simulação, já que apenas a visualização dos PORTs pode não ser o suficiente para obter informações.

\par Para interação com a simulação, o simulador utiliza a leitura do acelerômetro do \textit{smartphone} como entrada analógica e permite também o envio de comandos do GDB. A versão \textit{web} permite ainda a medição de parâmetros como o estado dos registradores, pilha, SDRAM e a velocidade do sistema, também permitindo controlar a velocidade de simulação.

\par Como dito anteriormente, o aplicativo não possui botões ou menus e a navegação por toques não é clara, mas é por meio dela é possível abrir o menu para carregar um código hexadecimal e acessar o \textit{prompt} do GDB. Um programa a ser simulado pode tanto ser escolhido de um banco de exemplos (com 4 códigos disponíveis no aplicativo) ou carregados pelo usuário a partir de um repositório do Dropbox.

\par O \textit{AndMCU} fornece um kit de desenvolvimento ao usuário e as possibilidades de interação com o aplicativo não vai muito além das possibilidades deste \textit{hardware} virtual (com exceção para o uso do sensor de luminosidade do \textit{smartphone} para entrada analógica). A única interação do usuário que é externo à este kit é na escolha do código a ser simulado ao iniciar o aplicativo.

\par Apesar disso, o sistema permite que diversas configurações sejam feitas no código em \textit{assembly} que será simulado. Entre as possibilidades estão o controle de velocidade de simulação, modo de simulação passo-a-passo, desabilitar os \textit{DIP Switches}, escrever conteúdo da memória em arquivo, entre outras possibilidades descritas na documentação.

\par O simulador fornece, assim como o \textit{BoardMicro - AVR Simulator}, um banco contendo 10 exemplos já codificados e um arquivo \textit{template} para servir de base para novos códigos. O usuário que desejar simular um código diferente deve adicioná-lo na pasta \url{/sdcard/AndMCU} do \textit{smartphone}.

\par E finalmente, o \textit{Arduino Simulator Mini Free} se mostrou-se o mais limitado em temos de funcionalidade. O simulador fornece 5 códigos exemplo para o usuário, que pode realizar modificações apenas de determinados parâmetros, como alterar o pino de saída, tempo de \textit{delay} e mensagem do display LCD, não sendo possível criar um código customizado para a simulação. 
\par O usuário também não pode fornecer dados de entrada durante a simulação, podendo apenas visualizar o funcionamento do circuito. Isso acaba invalidando um dos códigos exemplo, que requer uma entrada analógica em um circuito utilizando LDR.
\par O \textit{Arduino Simulator Mini Free} possui duas outras versões pagas na \textit{Amazon Store}, com diferentes projetos e a possibilidade de edição do circuito eletrônico em uma delas (segundo a descrição). No entanto, nenhuma destas versões foi testada.

\subsection{Requisitos do sistema e consumo de recursos}

\subsubsection{Sistema Operacional}

\par Todos os aplicativos suportam o sistema Android, com o \textit{Arduino Simulator Mini Free} disponível também para IOs (sob os nomes \textit{Arduino Simulator 2X - Learn and DIY Safely} e \textit{Arduino Simulator - Full Pack 2x}). A tabela~\ref{tab:comp_plataforma} indica qual a versão mínima do Android é requerida por cada aplicativo. Este valor foi obtido a partir da descrição do aplicativo nas lojas \textit{Google Play Store} e \textit{Amazon Store}.

\begin{table}[h]
	\centering
	\caption{Versão do Android requerida por cada aplicativo}
	\label{tab:comp_plataforma}
	\begin{tabular}{|c|c|}
		\hline
		\textbf{Aplicativo} & \textbf{Versão do mínima} \\ \hline
		Arduino Simulator Mini Free & 2.2 \\ \hline
		AndMCU & 2.3.3 \\ \hline
		BoardMicro - AVR Simulator & 4.0 \\ \hline		
		SOFIA & 5.0 \\ \hline
	\end{tabular}
\end{table}

\par Ao criar um projeto no Android Studio, pode-se verificar qual a distribuição de usuários em cada versão do Android. A figura~\ref{fig:dist_android} apresenta esta distribuição e por ela, pode-se observar que, com exceção do projeto SOFIA, todos os simuladores podem ser executados em 100\% dos dispositivos Android ativos no momento.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.45\textwidth]{./Resources/distrib_android}
	\caption{Distribuição acumulada de usuários Android. Como destacado, o simulador SOFIA poderá atingir pouco mais de 70\% dos dispositivos Android ativos no momento, porém este número tente a aumentar com a modernização dos aparelhos} 
	Fonte: Android Studio
	\label{fig:dist_android}
\end{figure}

\subsubsection{Tamanho}

\par O gráfico mostrado na figura~\ref{fig:comp_tamanho} mostra o tamanho do arquivo APK para cada aplicativo.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{./Resources/tamanho_apk}
	\caption{Tamanho do arquivo APK (MB) de cada aplicativo} 
	Fonte: Autor
	\label{fig:comp_tamanho}
\end{figure} 

\par Pode-se observar que o \textit{Arduino Simulator Mini Free} possui um tamanho muito superior aos demais, resultado este um tanto inesperado, uma vez que a versão \textit{Full Pack} deste aplicativo possui um tamanho menor de apenas 9MB.

\newpage
\subsubsection{Uso de CPU}

\par O uso de CPU foi medido utilizando um \textit{shell} remoto acessado pelo \textit{Android Debug Bridge} (adb). O comando \textit{top} pode ser utilizado de modo análogo ao \textit{htop} dos sistemas Linux, e mostra diversas informações a respeito dos processos em execução, incluindo o uso de CPU. O gráfico da figura~\ref{fig:comp_cpu} apresenta a média obtida das medições, com indicação do desvio padrão. O aplicativo \textit{AndMCU} foi testado em duas condições diferentes, para alta e baixa velocidade de simulação, definida pela diretriz \textit{.speed}.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{./Resources/uso_cpu}
	\caption{Consumo médio de CPU (\%) de cada aplicativo. Para cada processo, foram coletadas 397 amostras} 
	Fonte: Autor
	\label{fig:comp_cpu}
\end{figure} 

\par É difícil comparar o resultado do \textit{AndMCU} com os demais aplicativos pois, em todos eles, o código foi o mesmo (em C), a plataforma é a mesma (Arduino) e a frequência de intermitência é a mesma (500Hz), enquanto que o \textit{AndMCU} está em outro contexto, com código em \textit{assembly}, produzindo uma frequência de intermitência difícil de ser determinada. O que se observou, no entanto, foi que este aplicativo apresentou um consumo de CPU bastante reduzido em comparação aos demais, mesmo quando a velocidade de simulação foi configurada para a máxima possível.

\par Por outro lado, o simulador \textit{BoardMicro - AVR Simulator} apresentou um consumo muito maior que a média dos demais, resultado este que provavelmente está relacionado com sua velocidade de simulação, como mostra a seção~\ref{velocidade_simulacao}, enquanto o projeto SOFIA e o \textit{Arduino Simulator Mini Free} apresentaram resultados próximos da média.

\newpage

\par Esta medida de CPU tem impacto direto no consumo de bateria de cada aplicativo. A figura~\ref{fig:comp_bateria} apresenta um gráfico indicando o consumo médio percentual de bateria para cada aplicativo em um período de 2 horas, onde cada aplicativo ficou em execução contínua durante 30 minutos (o aplicativo \textit{AndMCU} foi utilizado em seu modo padrão, ou seja, baixa velocidade). Os resultados foram medidos com a ferramenta \textit{Battery Historian} e pode-se observar que o gráfico apresenta as mesmas proporções ao apresentado na figura~\ref{fig:comp_cpu}.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{./Resources/consumo_bateria}
	\caption{Consumo médio de Bateria (\%) de cada aplicativo em um período de 2 horas, com cada aplicativo executando o projeto \textit{Blink} continuamente por 30 minutos. Foram realizadas 5 medições para cada aplicativo.} 
	Fonte: Autor
	\label{fig:comp_bateria}
\end{figure} 

\subsubsection{Uso de Memória}

\par O uso de memória por cada aplicativo foi também medido do o uso do \textit{shell} remoto, com o comando \textit{dumpsys meminfo}. Segundo a documentação desta instrução~\cite{Meminfo}, o campo \textit{Proportional Set Size} (PSS), que é a soma da memória privada (região de memória pertencente apenas ao aplicativo e liberada ao sistema quando este é encerrado) e da memória compartilhada (total de memória compartilhada utilizada pelo aplicativo, dividida pelo número de processos que compartilham a esta região de memória), fornece uma boa medida do "peso" deste processo na memória principal, e portanto, este foi o valor utilizado para comparar o uso de memória entre os aplicativos. O gráfico da figura~\ref{fig:comp_ram} apresenta a média obtida das medições realizadas, com indicação do desvio padrão.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{./Resources/uso_ram}
	\caption{Consumo de memória (PSS em MB) de cada aplicativo. Foram realizadas 1000 medições para cada aplicativo} 
	Fonte: Autor
	\label{fig:comp_ram}
\end{figure} 

\par No quesito memória, embora o comentário a respeito do uso da estrutura \textit{Enum} na seção~\ref{profiling}, o projeto SOFIA se mostrou bastante competitivo em relação aos demais simuladores.

\par Também foi interessante notar, no \textit{AndMCU}, que a configuração de maior velocidade teve um consumo de memória ligeiramente menor que o modo de baixa velocidade (apesar do grande desvio obtido). A explicação para isso provavelmente se deve à taxa de atualização da tela nos diferentes modos, como explicado na documentação~\cite{AndMCU}, o modo de alta velocidade diminui a taxa de atualização e o oposto ocorre para o modo de baixa velocidade. Na seção~\ref{profiling} foi mostrado que este parâmetro tem grande impacto no consumo de CPU e de memória no Android.

%\subsubsection{Consumo de Bateria}
%
%\par Por fim, foi realizada a medida do consumo de bateria dos aplicativos utilizando a ferramenta \textit{Battery Historian}. Cada aplicativo foi executado durante 5 minutos (com o projeto \textit{Blink}) e obteve-se o percentual de uso de bateria de cada aplicativo durante todo o período de teste (aproximadamente 20 minutos). Este processo foi repetido três vezes e o gráfico da figura~\ref{fig:comp_bateria} apresenta a média obtida. Pode-se observar que os dados estão em concordância com o gráfico da figura~\ref{fig:comp_cpu}, como era de se esperar.
%
%\begin{figure}[h!]
%	\centering
%	\includegraphics[width=\textwidth]{./Resources/consumo_bateria}
%	\caption{Consumo percentual de bateria por cada aplicativo. Os demais recursos do sistema Android ficam responsáveis pelo percentual restante.} 
%	Fonte: Autor
%	\label{fig:comp_bateria}
%\end{figure} 
%
%\par Por não haver diferenças significativas entre os modos de alta e baixa velocidade, o simulador \textit{AndMCU} foi testado em seu modo padrão (baixa velocidade).

\subsection{Velocidade de simulação}
\label{velocidade_simulacao}

\par A velocidade de simulação aqui apresentada é uma medida da percepção que o usuário tem do sistema, quando comparado com o tempo do mundo real.

\par É possível ter uma ideia clara da velocidade de simulação do SOFIA, uma vez é apresenta a contagem do tempo simulado para o usuário. Este tempo simulado está reduzido em torno de 500x em comparação com o tempo real, já que são contados 2ms a cada segundo. Assim, o usuário percebe, na prática, um sistema com frequência de \textit{clock} efetiva de 32kHz, uma vez que que o \textit{hardware} no qual o simulador se baseia é o Arduino UNO com frequência de 16MHz.

\newpage

\par Para os demais simuladores, a velocidade de simulação foi medida alterando o projeto \textit{Blink} para que a intermitência fosse de 1s. O \textit{Arduino Simulator Mini Free} se mostrou bastante fiel ao tempo real, exibindo, de fato, uma intermitência de 1s, fazendo com que o usuário não perceba a diferença deste com um sistema real. Já o simulador \textit{BoardMicro - AVR Simulator} se mostra acelerado, com uma frequência  de intermitência 4x maior que a esperada.

\par Para o projeto \textit{AndMCU}, não foi possível ter uma ideia clara de sua real velocidade de simulação pois, como já mencionado anteriormente, este aplicativo está em outro contexto do qual não é bem determinado/conhecido como no caso do Arduino. No entanto, é possível ler na documentação do projeto que o sistema possui uma velocidade de simulação adequada para que os resultados possam ser observados por estudantes, ou, como o autor coloca em outras palavras, "não se deve esperar deste simulador uma velocidade elevada como o de um emulador de CPU" (em tradução live)~\cite{AndMCU}.

\subsection{Documentação}

\par O projeto SOFIA conta com uma documentação \textit{on-line} (em inglês) hospedada no Gitbook. Esta documentação pode ser acessada a partir do repositório do Github ou de dentro do próprio aplicativo, nos menus de ajuda e de informações do projeto.

\par A documentação do projeto SOFIA é dividido em 3 partes. A primeira mostra uma visão geral, apresentando uma breve descrição do que é o projeto, seus objetivos, público alvo, etc. A segunda parte é um manual do usuário e descreve, passo-a-passo, quais os procedimentos para baixar e instalar o simulador (bem como a versão modificada da IDE do Arduino) e como utilizá-lo, detalhando todos os seus recursos. Por fim, a última parte apresenta uma visão mais voltada ao desenvolvimento do projeto, com diagramas, métricas de \textit{software} e comentários a respeito do código desenvolvido. O \textit{link} para acessar a documentação do projeto SOFIA é mostrado abaixo:

\begin{itemize}
\item \textbf{Documentação SOFIA:}
\begin{itemize}
\item \url{https://project-sofia.gitbook.io/project/}
\end{itemize} 
\end{itemize}

\par O aplicativo \textit{AndMCU} também conta com duas páginas de documentação \textit{on-line} (também em inglês) hospedadas no Google Sites e que podem ser acessadas a partir da página de \textit{download} do aplicativo na \textit{Google Play Store}.

\par Essa documentação apresenta as características e funcionalidades do sistema; o conjunto de instruções do simulador, bem como algumas diretrizes em \textit{assembly} que podem ser utilizadas; detalham a organização do processador que foi implementado, mostrando seu mapa de memória, esquema de ligação das entradas e saída e uma explicação sobre a CPU e seus registradores; apresenta o \textit{hardware} virtual; entre outras informações. Abaixo é mostrado o endereço eletrônico onde este material pode ser acessado
\begin{itemize}
	\item \textbf{Documentação \textit{AndMCU}:}
	\begin{itemize}
	\item \url{https://sites.google.com/site/hkonstas/android-stuff/andmcu}
	\item \url{https://sites.google.com/site/hkonstas/android-stuff/andmcu/andmcu-documentation}
		\end{itemize}
\end{itemize}

\par Pouca informação foi encontrada para os projetos \textit{BoardMicro - AVR Simulator} e \textit{Arduino Simulator Mini Free}, além das descrições presentes nas páginas de \textit{download} destes aplicativos. O projeto \textit{BoardMicro - AVR Simulator} conta apenas com um breve arquivo \textit{README} em seu repositório no Github, disponível no \textit{link} abaixo:

\begin{itemize}
	\item \textbf{Repositório do projeto \textit{BoardMicro - AVR Simulator}:}
	\begin{itemize}
		\item \url{https://github.com/blakewford/boardmicro}
	\end{itemize}
\end{itemize}

\par Quanto ao \textit{Arduino Simulator Mini Free}, um vídeo disponível no YouTube foi o único material encontrado a respeito da ferramenta. O vídeo mostra a versão do aplicativo para IOs e pode ser acessado pelo \textit{link} a seguir:

\begin{itemize}
	\item \textbf{Vídeo informativo do aplicativo \textit{Arduino Simulator Mini Free}:}
	\begin{itemize}
		\item \url{https://www.youtube.com/watch?v=LJxdy6FHVGg}
	\end{itemize}
\end{itemize}

\subsection{Disponibilidade}

\par Todos os aplicativos apresentados podem ser obtidos gratuitamente na internet. O projeto \textit{AndMCU} pode ser baixado na \textit{Google Play Store}, enquanto o \textit{Arduino Simulator Mini Free} está disponível na \textit{Amazon Appstore}. O simulador \textit{BoardMicro - AVR Simulator} pode ser adquirido em ambas, \textit{Google Play Store} e \textit{Amazon Appstore}, além de ser um projeto de código aberto disponível no Github. O projeto SOFIA, por ainda estar em fase experimental, pode ser baixado apenas na forma de código-fonte pelo Github, ou na forma de APK no site do projeto no Gitbook, apresentado na seção~\ref{codigo_documentacao}, devendo ser disponibilizado também na \textit{Google Play Store} posteriormente. Além disso, o projeto SOFIA é o único com uma versão em português.

\par O simulador \textit{Arduino Simulator Mini Free} possui ainda duas versões pagas para Android. Uma delas se chama \textit{Arduino Simulator Mini}, e custa R\$ 2,35. A outra se chama \textit{Arduino Simulator DIY Safely}, e possui o preço de R\$ 4,44. Embora não fique claro quais as diferenças entre cada versão olhando apenas para a descrição dos aplicativos, pode-se notar uma grande diferença nas permissões que cada aplicativo requer para funcionar. A versão gratuita requer uma quantidade enorme de permissões, tais como acesso ao GPS, leitura do histórico de navegação e favoritos do navegador \textit{web}, entre outras que não estão relacionadas com sua funcionalidade, chegando a ser reconhecida como uma ameaça pelo antivírus AVG Pro. O \textit{Arduino Simulator Mini} requer permissões para gravar áudio acessar o cartão SD, enquanto que o \textit{Arduino Simulator DIY Safely} apenas exige a permissão para acessar o recurso de vibração do \textit{smartphone}.

\par Vale mencionar também que o \textit{Arduino Simulator Mini Free} é o único dos simuladores testados a conter propagandas, que são exibidas a qualquer momento durante o uso do sistema Android e não apenas dentro do aplicativo.

\section{Código}
\label{codigo_documentacao}

\par O código-fonte do projeto foi disponibilizado em um repositório \textit{on-line} no Github sob a licença \textit{Apache 2.0}. As modificações feitas na IDE do Arduino também estão disponíveis no Github sob a mesma licença.

\begin{itemize}
\item \textbf{Projeto SOFIA:} \url{https://github.com/kollinslima/ProjectSOFIA}

\item \textbf{Arduino IDE:} \url{https://github.com/kollinslima/Arduino/tree/android}
\end{itemize}

