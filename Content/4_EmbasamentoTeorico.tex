\chapter{Embasamento Teórico}
\label{EmbasamentoTeorico}

\par Neste capítulo serão apresentados o funcionamento e as características de cada módulo presente no microcontrolador usado no Arduino UNO (ATmega328P) e que foram implementados no simulador. Todas as informações foram retiradas da folha de dados do componente~\cite{atmega328p_datasheet}, exceto onde indicado.

\section{Visão Geral}

\par O ATmega328P é um microcontrolador RISC de 8-bits e arquitetura Harvard (memória de dados separada da memória de programa). Possui 28 pinos (encapsulamento PDIP), sendo 23 programáveis e pode tralhar com frequência máxima de operação de 20MHz.
\par Entre os periféricos que estão integrados neste dispositivo, pode-se listar:
\begin{itemize}
	\item Dois temporizadores de 8-bits com \textit{prescaler} separados;
	\item Um temporizador de 16-bits;
	\item 6 canais de PWM;
	\item Conversor Analógico-Digital de 10-bits (8 canais multiplexados);
	\item Duas interfaces de comunicação serial SPI;
	\item Uma USART (\textit{Universal Synchronous Asynchronous Receiver Transceiver}) serial;
	\item Uma interface serial TWI (\textit{2-wire Serial Interface}), compatível com $I^{2}C$ da Philips;
	\item \textit{Watchdog Timer} programável com oscilador separado;
	\item Entre outros.
\end{itemize}

\par A figura~\ref{block_diagram_ATmega328P} apresenta um diagrama de blocos da organização interna do microcontrolador.

 \begin{figure}[h]
 	\centering
 	\includegraphics[width=\textwidth]{./Resources/Block_diagram_ATmega328P}
 	\caption{Diagrama de blocos da organização interna do ATmega328P}
 	Fonte: Folha de dados ATmega328P
 	\label{block_diagram_ATmega328P}
 \end{figure}

\section{CPU}

\par A CPU do ATmega328P é apresentada na figura~\ref{block_diagram_cpu}. Ela possui um banco de 32 registradores de 8-bits, com os 6 últimos podendo ser utilizados como registradores de 16-bits (chamados de registrador X (R27:R26), Y(R29:R28) e Z(R31:R30)); PC de 14-bits; Registrador de \textit{status} (8-bits) que armazenam as \textit{flags} geradas por cada operação aritmética/lógica (zero, \textit{carry}, \textit{overflow}, etc); \textit{Stack Pointer} de 16-bits e demais registradores auxiliares.
 \begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{./Resources/Block_diagram_cpu}
	\caption{Diagrama de blocos da organização da CPU}
	Fonte: Folha de dados ATmega328P
	\label{block_diagram_cpu}
\end{figure}

\par A CPU utiliza um \textit{pipeline} de um estágio o que, junto com a arquitetura Harvard, permite que o sistema atinja uma velocidade máxima de 1 MIPS/MHz. 
\par Em chamadas de sub-rotinas e interrupções, a CPU utiliza uma pilha implementada diretamente na memória SDRAM, cujo topo é apontado pelo registrador \textit{Stack Pointer}. Esta estrutura de dados cresce do endereço mais alto da memória para o endereço mais baixo, de forma que o \textit{Stack Pointer} deve ser corretamente inicializado para o último endereço da memória SDRAM antes de ser utilizado.
\par As interrupções no ATmega328P são organizadas segundo sua prioridade. A tabela~\ref{interruption_vector} mostra o vetor de interrupções, contendo o endereço de desvio para cada tipo de interrupção. Quanto mais baixo o endereço, maior é a prioridade (o \textit{RESET} é a interrupção de maior prioridade no sistema).

\begin{table}
	\centering
	\caption{Vetor de interrupções ATmega328P}
	\label{interruption_vector}
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Endereço de Desvio} & \textbf{Interrupção} & \textbf{Descrição}\\ \hline
		0x00 & RESET & Interrupção de Reset   \\ \hline
		0x02 & INT0  & Interrupção Externa 0   \\ \hline
		0x04 & INT1 &  Interrupção Externa 1  \\ \hline
		0x06 & PCINT0 & Interrupção de mudança de estado 0    \\ \hline
		0x08 & PCINT1 & Interrupção de mudança de estado 1   \\ \hline
		0x0A & PCINT2 & Interrupção de mudança de estado 2   \\ \hline
		0x0C & WDT & Estouro do \textit{Watchdog Timer}    \\ \hline
		0x0E & TIMER2\_COMPA  & Comparação \textit{Timer} 2 canal A    \\ \hline
		0x10 & TIMER2\_COMPB  & Comparação \textit{Timer} 2 canal B    \\ \hline
		0x12 & TIMER2\_OVF  & Estouro do \textit{Timer} 2    \\ \hline
		0x14 & TIMER1\_CAPT  & Captura de evento \textit{Timer} 1    \\ \hline
		0x16 & TIMER1\_COMPA  & Comparação \textit{Timer} 1 canal A    \\ \hline
		0x18 & TIMER1\_COMPB  & Comparação \textit{Timer} 1 canal B    \\ \hline
		0x1A & TIMER1\_OVF  & Estouro do \textit{Timer} 1    \\ \hline
		0x1C & TIMER0\_COMPA  & Comparação \textit{Timer} 0 canal A    \\ \hline
		0x1E & TIMER0\_COMPB  & Comparação \textit{Timer} 0 canal B    \\ \hline
		0x20 & TIMER0\_OVF  & Estouro do \textit{Timer} 0    \\ \hline
		0x22 & SPI STC  & Transferência SPI completa    \\ \hline
		0x24 & USART\_RX  & Recepção USART completa    \\ \hline
		0x26 & USART\_UDRE  & Registrador de dados vazio (USART)    \\ \hline
		0x28 & USART\_TX  & Transmissão USART completa    \\ \hline
		0x2A & ADC  & Conversão analógico-digital completa    \\ \hline
		0x2C & EE READY  & EEPROM pronta    \\ \hline
		0x2E & ANALOG COMP  & Comparador analógico    \\ \hline
		0x30 & TWI & Interface serial $I^{2}C$ \\ \hline
		0x32 & SPM READY & Armazenamento na memória de programa \\ \hline
	\end{tabular}
\end{table}

\par Importante resaltar que as interrupções são desabilitadas automaticamente ao iniciar o tratamento de uma rotina de interrupção (e reabilitadas ao terminar), no entanto, este comportamento pode ser alterado por \textit{software} reabilitando as interrupções no começo da rotina.
\par As interrupções são classificadas em duas classes: as disparadas por envento e as disparadas por uma condição. 
\par Quando as interrupções são disparadas por eventos, é habilitada uma \textit{flag} indicando a ocorrência do evento. Se a interrupção estiver ativada para aquele evento, a interrupção será tratada ou enfileirada para execução posterior. Ou seja, em interrupções por evento, os eventos que não foram tratados são lembrados e serão executados em ordem de prioridade assim que possível.
\par Quando o disparo ocorre por uma condição, a chamada para a rotina de interrupção permanece ativa enquanto a condição estiver presente. Este tipo de interrupção não necessariamente habilita \textit{flags} de modo que, se a condição for removida antes que a CPU possa tratar a interrupção correspondente, a interrupção não ocorrerá.

\section{Memória de Programa}
\label{sec:memoria_programa}

\par A memória de programa é uma FLASH de 32kB x 8-bits, que está organizada da forma 16kB x 16-bits pois cada instrução do microcontrolador é de 16 ou 32-bits. Assim, o registrador PC de 14-bits pode fazer um endereçamento a palavra na memória de programa. 
\par A figura~\ref{program_memory} mostra a organização da memória de programa. Pode-se notar que o \textit{Boot Loader} está posicionado em uma seção separada do restante da memória e isso ocorre por questões de segurança.

 \begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{./Resources/program_memory}
	\caption{Memória de programa ATmega328P}
	Fonte: Folha de dados ATmega328P
	\label{program_memory}
\end{figure}

\par As instruções a serem preenchidas na memória de programa são fornecidas pelo arquivo hexadecimal gerado pelo compilador. Este arquivo segue o padrão Intel e está disposto conforme mostra a tabela~\ref{tab:intel_hex}~\cite{IntelHex}:

\begin{table}[h]
	\centering
	\caption{Formato dos registros do arquivo hexadecimal no padrão Intel}
	\label{tab:intel_hex}
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		Início do registro & Contagem de bytes & Endereço &  Tipo de registro & Dado & \textit{Checksum} \\ \hline
	\end{tabular}
\end{table}

\begin{itemize}
	\item Início do registro: Denotado pelo símbolo ":" (1 byte do registro).
	\item Contagem de bytes: Indica a quantidade de bytes a serem lidos no campo de dados (1 byte do registro).
	\item Endereço: Indica o endereço de memória no qual deve se iniciar o preenchimento dos dados. Este endereço pode não ser igual ao endereço físico da memória (2 bytes do registro).
	\item Tipo do registro: Indica o que o registro representa (1 byte do registro), podendo ser:
	
	\begin{itemize}
		\item 00: Dado
		\item 01: Fim do arquivo
		\item 02: Segmento estendido de memória. O valor do campo dado é armazenado e o endereço físico de memória dos registros seguintes é calculado como sendo o campo de endereço somado ao segmento estendido multiplicado por 16.
		\item 03: Início do segmento de memória. O valor contido no campo dado é carregado para os registradores CS e IP para os processadores 8086 e 80186
		\item 04: Segmento estendido de memória Linear. O valor do campo dado é armazenado e o endereço físico de memória dos registros seguintes é calculado como sendo o campo de endereço concatenado ao segmento estendido, sendo este último a parte mais significativa do endereço.
		\item 05: Início do endereço linear. Aponta para o endereço de memória onde o programa deve executar.
	\end{itemize}

	\item Dado: Contém os dados do registro no formato \textit{Little-endian} (primeiro byte é o menos significativo) (tamanho variável no registro).
	
	\item \textit{Checksum}: Complemento de dois do byte menos significativo da soma de todos os bytes anteriores do registro (1 byte do registro).	
\end{itemize}

\section{Memória de Dados}

\par O ATmega328P possui 2kB de memória de dados SDRAM, além do espaço de dados reservado aos registradores.
\par Apesar dos registradores não estarem fisicamente implementados na memória de dados, o microcontrolador faz um mapeamento linear da memória de modo a se obter, na prática, uma memória como mostrado na figura~\ref{data_memory}.

 \begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/data_memory}
	\caption{Memória de dados ATmega328P}
	Fonte: Folha de dados ATmega328P
	\label{data_memory}
\end{figure}

\par Existem diferentes modos de endereçamento que são aplicados à memória de dados. Todo o espaço de endereçamento suporta qualquer um dos modos listados, são eles:

\begin{itemize}
	\item Direto: Acesso direto ao endereço desejado;
	\item Indireto com deslocamento: Acesso à 63 endereços deslocados a partir do endereço base, dado pelo registrador Y ou Z.
	\item Indireto: Acesso ao endereço dado pelos registradores X, Y ou Z.
	\item Indireto com pré-decremento: Registradores X, Y ou Z são decrementados antes de serem utilizados como ponteiro para endereçamento.
	\item Indireto com pós-incremento: Registradores X, Y ou Z são incrementados depois de serem utilizados como ponteiro para endereçamento.
\end{itemize}


\section{Módulo de Entrada e Saída Digital}
\label{sec:e_s}

\par Como dito anteriormente, o ATmega328P possui 23 programáveis, que podem ser utilizados para entrada ou saída de sinal. A figura~\ref{fig:io_module} mostra a organização interna do módulo de entrada/saída (E/S) do microcontrolador.

 \begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/io_module}
	\caption{Organização do módulo de Entrada/Saída (E/S) do ATmega328P}
	Fonte: Folha de dados ATmega328P
	\label{fig:io_module}
\end{figure}

\par Os pinos podem ser configurados por meio dos registradores DDRxn, PORTxn e PINxn, onde "x" corresponde à letra do port e "n" corresponde ao número do bit no registrador. O registrador DDRxn é utilizado para configuração da direção do pino (entrada ou saída), enquanto o PORTxn configura o estado do pino (nível alto ou baixo) se é um pino de saída, caso contrário, seu efeito será ativar ou desativar o resistor de \textit{pull-up} interno, se este estiver habilitado no registrador MCUCR.
\par O registrador PINxn é um registrador apenas de leitura, que armazena o valor da entrada do pino. No entanto, é possível escrever um valor "1" neste registrador. O efeito desta escrita será a inversão do valor contido no registrador PORTxn, independente da configuração do pino como entrada ou saída.
\par Além de entrada e saída digital, alguns pinos possuem funções adicionais, tais como entrada analógica, saída de PWM, etc, que são multiplexadas ao funcionamento normal do pino.
\par O módulo de E/S pode disparar interrupções externas (pinos INT) ou interrupções por mudança de valor (pinos PCINT). As interrupções externas podem ser configuradas para gerar interrupção por mudança de estado, borda de subida ou descida ou disparo por nível baixo, enquanto as interrupções por mudança de valor não são configuráveis e apenas respondem à mudança de estado na entrada. É interessante notar que as interrupções por nível são detectadas de maneira assíncrona, podendo ser utilizadas para despertar o sistema se este estiver em determinados modos de hibernação.

\section{Temporizadores}
\label{sec:timers}

\par O ATmega328P possui 3 temporizadores internos, chamados \textit{Timer 0},\textit{Timer 1} e \textit{Timer 2}. Os modos de funcionamento disponíveis para cada temporizador são semelhantes, sendo eles: modo normal, modo CTC (\textit{Clear on Compare Match}), \textit{Fast PWM} e PWM com correção de fase. As fontes de clock para os temporizadores podem ser externa ou interna. Quanto interna, existe a possibilidade de controle da frequência por meio de um \textit{prescaler}.
\par O \textit{Timer 1} é um contador de 16-bits, enquanto os \textit{Timers 0} e \textit{2} são de 8-bits. O \textit{Timer 2} possui uma função adicional de funcionamento assíncrono, podendo assim utilizar uma fonte de clock externa aplicada aos pinos TOSC1 e TOSC2 (os \textit{Timers 0} e \textit{1}, embora também possam ser acionados por clock externo, a detecção de borda que é realizada nos pinos T0 e T1 é feita de maneira síncrona). Também por seu funcionamento assíncrono, pode ser utilizado para despertar o sistema caso este esteja em determinados modos de hibernação. 
\par Os temporizadores podem atuar nos pinos de saída OCxA e OCxB, sobrescrevendo a operação normal do pino. Para isso, entretanto, é preciso que os pinos sejam configurados como saída no registrador DDRxn.
\par As figuras~\ref{fig:timer0_2} e~\ref{fig:timer1} apresentam a organização interna dos \textit{Timers 0/2} e do \textit{Timer 1} respectivamente.

 \begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/timer0_2}
	\caption{Organização do módulo de \textit{Timer 0/2} do ATmega328P}
	Fonte: Folha de dados ATmega328P
	\label{fig:timer0_2}
\end{figure}

 \begin{figure}[]
	\centering
	\includegraphics[width=\textwidth]{./Resources/timer1}
	\caption{Organização do módulo de \textit{Timer 1} do ATmega328P. Para contar em 16-bits, os registradores TCNTn, ICRn, OCRnA e OCRnB são divididos em dois registradores de 8-bits (\textit{Low} e \textit{High}).}
	Fonte: Folha de dados ATmega328P
	\label{fig:timer1}
\end{figure}

\subsection{Modo Normal}

\par No modo normal de operação, a contagem é feita continuamente até atingir o valor máximo (0xFF para 8-bits e 0xFFFF para 16-bits), quando ocorre um \textit{overflow} e o sistema reinicia a contagem do zero. O estouro do contador pode ser utilizado para gerar uma interrupção.
\par Os registradores OCRnA e OCRnB são continuamente comparados com o valor de TCNTn (que armazena a contagem) e em caso de \textit{match}, podem gerar interrupções no sistema e/ou atuar nos pinos OCxA e OCxB, podendo levá-los à nível alto, baixo ou inverter seus valores.

\subsection{Modo CTC}

\par O modo de funcionamento CTC apresenta as mesmas possibilidades do modo normal, no entanto o valor máximo de contagem é igual ao valor contido no registrador OCRxA, que pode ser ajustado a qualquer momento (Para o \textit{Timer 1}, existe a opção de utilizar o registrador ICR1). 
\par No entanto, diferente do modo normal, o reinício da contagem não pode gerar interrupção de \textit{overflow}. Isso só é possível caso OCRxA (ou ICR1) seja igual à 0xFF (8-bits) ou 0xFFFF (16-bits). Neste caso, o modo CTC e o modo normal se comportam de maneiras idênticas.

\subsection{Modo \textit{Fast PWM}}

\par No modo \textit{fast PWM}, assim como no modo normal, a contagem é feita continuamente do valor mais baixo (0) ao valor mais alto (0xFF para 8-bits ou, no caso do \textit{Timer 1}, este valor pode ser configurado para 0xFF, 0x1FF ou 0x3FF), havendo a possibilidade de alteração deste valor utilizando o registrador OCRnA (ou ICR1 para o \textit{Timer 1}), como ocorre no modo CTC. Também como no modo normal, o estouro do contador pode gerar interrupção de \textit{overflow}.
\par A diferença do modo \textit{fast PWM} está na maneira como um \textit{math} entre TCNTn e OCRnA/OCRnB é tratado. Além das possibilidades de disparo de interrupção, os pinos OCxA/OCxB podem ser configurados para apresentar nível baixo em caso de \textit{math} e nível alto no estouro do contador (modo de funcionamento não-invertido), ou o contrário (modo de funcionamento invertido) de modo a gerar uma onda quadrada.

\par Outra característica do modo \textit{fast PWM} está na atualização dos valores de OCRnA/OCRnB. Enquanto no modo normal e no modo CTC estes valores são atualizados imediatamente, no modo \textit{fast PWM} a atualização dos valores ocorre apenas quando TCNTn atinge o valor máximo da contagem. Com isso, evita-se que uma comparação seja perdida caso o valor de OCRnA/OCRnB seja menor que o valor de TCNTn, o que pode ocorrer nos modos normal e CTC.

\subsection{Modo PWM com Correção de Fase}

\par O modo PWM com correção de fase faz a contagem progressiva até o valor máximo (fixo ou variável, da mesma forma como ocorre no modo \textit{fast PWM}), seguido de uma contagem regressiva até o valor mínimo (0), quando é disparada a condição de \textit{overflow}. Esta característica, faz com que este modo atinga velocidades 2x menor que o modo \textit{fast PWM}.

\par Neste modo de operação, os pinos OCxA/OCxB podem ser configurados para apresentar nível baixo em caso de \textit{math} com OCRxA/OCRxB (na contagem progressiva) e nível alto em caso de \textit{math} (na contagem regressiva), ou o contrário, gerando uma onda quadrada. No caso do \textit{Timer 1}, ainda existe a possibilidade de inverter o valor de OC1A em caso de \textit{match}, seja em contagem progressiva ou regressiva.

\par Assim como no modo \textit{fast PWM}, a atualização do valor de OCRxA/OCRxB não é instantânea, ocorrendo apenas no momento em que que a contagem atinge o valor máximo. Importante resaltar que, tanto para o modo de correção de fase, quanto para o \textit{fast PWM}, o valor de ICR1 é atualizado imediatamente, o que pode ocasionar em uma perda na comparação com TCNTx caso este registrador estiver sendo usado para definir o topo da contagem.

\subsection{Modo PWM com Correção de Fase e Frequência}

\par Este modo de operação está disponível apenas para o \textit{Timer 1}. Seu funcionamento é idêntico ao modo de correção de fase, a diferença está no momento da atualização dos registradores OCRxA/OCRxB, que não ocorre no topo da contagem mas sim ao atingir o valor mínimo. Com isso, pode-se garantir a simetria dos pulsos gerados.

\subsection{Captura de Eventos}

\par O \textit{Timer 1} apresenta uma funcionalidade extra que é a captura de eventos. Esta funcionalidade permite que o valor da contagem presente em TCNTx seja capturado e salvo no registrador ICR1. 
\par O disparo do evento de captura pode ser dado pela saída do comparador analógico ou pelo pino ICP1, que pode ser configurado para disparo por borda de subida ou descida.
\par Se o registrador ICR1 não estiver sendo utilizado como valor máximo do contador, esta é a única forma de escrever neste registrador.

\section{Conversor A/D}
\label{sec:conversor_ad}

\par O ATmega328P possui um conversor analógico/digital (A/D) com resolução de 10-bits e 8 canais de entrada (ADC0-ADC7) multiplexados, além de duas entradas fixas (0V e 1,1V) e um sensor de temperatura integrado. A figura~\ref{fig:adc} apresenta a organização interna do conversor A/D.

\par O conversor possui uma entrada de alimentação separada que é feita por meio do pino AVcc. Esta entrada pode ser utilizada como tensão de referência ($V_{ref}$) para conversão, ou ainda, podem ser escolhidas outras opções por meio do registrador ADMUX, tais como a entrada AREF ou referência interna de 1,1V.

\par Por ser um conversor de 10-bits, são necessários 2 registradores para armazenar o resultado da conversão, são eles o ADCL e o ADCH. O resultado da conversão é alinhado à esquerda por padrão, no entanto esta opção pode ser alterada para alinhamento à direita por meio do registrador ADMUX. A figura~\ref{fig:alinhamento} mostra como o resultado é armazenado nos registradores ADCL e ADCH para cada modo.

\begin{figure}[h]
	\centering
	\begin{subfigure}{0.75\textwidth}
		\centering
		\includegraphics[width = \textwidth]{./Resources/adc_left_align}
		\caption{Alinhamento à esquerda}
	\end{subfigure}
	
	%Line Break
	
	\begin{subfigure}{0.75\textwidth}
		\centering
		\includegraphics[width = \textwidth]{./Resources/adc_right_align}
		\caption{Alinhamento à direita}
	\end{subfigure}
	\caption{Alinhamento do resultado nos registradores ADCH e ADCL}
	Fonte: Autor.
	\label{fig:alinhamento}
\end{figure}

 \begin{figure}
	\centering
	\includegraphics[width=\textwidth]{./Resources/adc}
	\caption{Organização do conversor A/D}
	Fonte: Folha de dados ATmega328P
	\label{fig:adc}
\end{figure}

\par Por segurança, uma leitura no registrador ADCL bloqueia a permissão de escrita nos registradores ADCL e ADCH, garantindo assim que o dado lido é referente à mesma conversão (o acesso é liberado novamente ao realizar uma leitura em ADCH). Caso o resultado esteja alinhado à direita, pode-se obter um valor convertido de 8-bits apenas lendo o registrador ADCH.

\par Para iniciar uma conversão é necessário colocar em nível alto os bits ADEN (habilita o conversor) e ADSC. A conversão é então inicializada e ADSC permanece em nível alto durante todo o tempo de conversão. Ao final, o bit ADSC é resetado por hardware e a flag ADIF é setada, podendo gerar uma interrupção se esta estiver configurada. O resultado de uma conversão é dada pela equação~\ref{eq:adc_result}.

\begin{equation}
	ADC = \frac{V_{in} * 1024}{V_{ref}}
	\label{eq:adc_result}
\end{equation}

\par Valores de entrada superiores à $V_{ref}$ terão valores convertidos próximos à 0x3FF (máximo valor para 10-bits).

\par É possível configurar um evento para o disparo do conversor A/D ou utilizá-lo no modo \textit{Free Run}, em que o disparo do conversor é feita pela própria \textit{flag} do conversor (ADIF), fazendo com que uma nova conversão comece imediatamente após a outra. Para utilizar este modo, a \textit{flag} ADIF precisa ser limpa a cada conversão, o que é feito automaticamente se for utilizada interrupção. A tabela~\ref{tab:disparo_adc} apresenta todas as possibilidades de disparo do conversor A/D.

\begin{table}[h]
	\centering
	\caption{Modos de disparo do conversor A/D}
	\label{tab:disparo_adc}
	\begin{tabular}{|c|c|}
		\hline
		ADTS[2:0] & Disparo \\ \hline
		000& Modo \textit{Free Run}  \\ \hline
		001& Saída do comparador analógico \\ \hline
		010& Interrupção externa 0 \\ \hline
		011& \textit{Math} A \textit{Timer} 0 \\ \hline
		100& \textit{Overflow Timer 0} \\ \hline
		101& \textit{Math} B \textit{Timer} 1 \\ \hline
		110& \textit{Overflow Timer 1} \\ \hline
		111& Captura de evento \textit{Timer} 1 \\ \hline
	\end{tabular}
\end{table}

\par Um recurso extra oferecido pelo microcontrolador é o sensor de temperatura integrado. Este sensor é capaz de realizar medições entre -45\textdegree C e 85\textdegree C, com precisão de $\pm$10\textdegree C. 
\par Para utilizar este sensor, é preciso configurar o $V_{ref}$ para a entrada interna de 1,1V. A temperatura (em \textdegree C) é dada pela equação~\ref{eq:adc_temperatura}.

\begin{equation}
	T = \frac{[ADCH << 8 | ADCL] - T_{OS}}{k}
	\label{eq:adc_temperatura}
\end{equation}

\par Onde $T_{OS}$ é um valor inserido na EEPROM de cada componente como parte dos testes em produção e k é um valor a ser determinado na calibração. (Na prática, utiliza-se $T_{OS}$ = 324,31 e k = 1,22\footnote{\url{https://playground.arduino.cc/Main/InternalTemperatureSensor}})