\chapter{Embasamento Teórico}
\label{EmbasamentoTeorico}

\par Neste capítulo será explicado o funcionamento e as características de cada módulo presente no microcontrolador do Arduino UNO (ATmega328P) que foram implementados no simulador, além de uma breve teoria a respeito de processo de desenvolvimento e teste de \textit{software}. No que diz respeito ao ATmega3228P, todas as informações foram retiradas da folha de dados do componente~\cite{atmega328p_datasheet}, exceto onde indicado.

\section{Microcontrolador ATmega328P}

\subsection{Visão Geral}

\par O ATmega328P é um microcontrolador RISC de 8-bits e arquitetura Harvard (memória de dados separada da memória de programa). Possui 28 pinos (encapsulamento PDIP), sendo 23 programáveis e pode trabalhar com frequência máxima de operação de 20MHz.
\par Entre os periféricos que estão integrados neste dispositivo, pode-se listar:
\begin{itemize}
	\item Dois temporizadores de 8-bits com \textit{prescaler} separados;
	\item Um temporizador de 16-bits;
	\item 6 canais de PWM;
	\item Conversor A/D de 10-bits (8 canais multiplexados);
	\item Duas interfaces de comunicação serial SPI;
	\item Uma USART serial;
	\item Uma interface serial TWI, compatível com $I^{2}C$ da Philips;
	\item \textit{Watchdog Timer} programável com oscilador separado;
	\item Entre outros.
\end{itemize}

\par A figura~\ref{block_diagram_ATmega328P} apresenta um diagrama de blocos da organização interna do microcontrolador.

 \begin{figure}[h]
 	\centering
 	\includegraphics[width=\textwidth]{./Resources/Block_diagram_ATmega328P}
 	\caption{Diagrama de blocos da organização interna do ATmega328P}
 	Fonte: Folha de dados ATmega328P
 	\label{block_diagram_ATmega328P}
 \end{figure}

\subsection{CPU}

\par A CPU do ATmega328P é apresentada na figura~\ref{block_diagram_cpu}. Ela possui um banco de 32 registradores de 8-bits, com os 6 últimos podendo ser utilizados como registradores de 16-bits (chamados de registrador X (R27:R26), Y(R29:R28) e Z(R31:R30)); PC de 14-bits; Registrador de \textit{status} (8-bits), que armazena as \textit{flags} geradas por cada operação aritmética/lógica (zero, \textit{carry}, \textit{overflow}, etc); \textit{Stack Pointer} de 16-bits e demais registradores auxiliares. A CPU utiliza um estágio de \textit{pipeline} que, junto com a arquitetura Harvard, permite que o sistema atinja uma velocidade máxima de 1 MIPS/MHz. 
 \begin{figure}[h!]
	\centering
	\includegraphics[scale=0.6]{./Resources/Block_diagram_cpu}
	\caption{Diagrama de blocos da organização da CPU}
	Fonte: Folha de dados ATmega328P
	\label{block_diagram_cpu}
\end{figure}

\par Em chamadas de sub-rotinas e interrupções, a CPU utiliza uma pilha implementada diretamente na memória SDRAM, cujo topo é apontado pelo registrador \textit{Stack Pointer}. Esta estrutura de dados cresce do endereço mais alto da memória para o endereço mais baixo, de forma que o \textit{Stack Pointer} deve ser corretamente inicializado para o último endereço da memória SDRAM antes de ser utilizado.
\par As interrupções no ATmega328P são organizadas segundo sua prioridade. A tabela~\ref{interruption_vector} mostra o vetor de interrupções, contendo o endereço de desvio para cada tipo de interrupção. Quanto mais baixo o endereço, maior é a prioridade (o \textit{RESET} é a interrupção de maior prioridade no sistema). Importante resaltar que as interrupções são desabilitadas automaticamente ao iniciar o tratamento de uma rotina de interrupção (e reabilitadas ao terminar), no entanto, este comportamento pode ser alterado por \textit{software}, reabilitando as interrupções no começo da rotina.

\begin{table}[p!]
	\centering
	\caption{Vetor de interrupções ATmega328P}
	\label{interruption_vector}
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Endereço de Desvio} & \textbf{Interrupção} & \textbf{Descrição}\\ \hline
		0x00 & RESET & Interrupção de Reset   \\ \hline
		0x02 & INT0  & Interrupção Externa 0   \\ \hline
		0x04 & INT1 &  Interrupção Externa 1  \\ \hline
		0x06 & PCINT0 & Interrupção de mudança de estado 0    \\ \hline
		0x08 & PCINT1 & Interrupção de mudança de estado 1   \\ \hline
		0x0A & PCINT2 & Interrupção de mudança de estado 2   \\ \hline
		0x0C & WDT & Estouro do \textit{Watchdog Timer}    \\ \hline
		0x0E & TIMER2\_COMPA  & Comparação \textit{Timer} 2 canal A    \\ \hline
		0x10 & TIMER2\_COMPB  & Comparação \textit{Timer} 2 canal B    \\ \hline
		0x12 & TIMER2\_OVF  & Estouro do \textit{Timer} 2    \\ \hline
		0x14 & TIMER1\_CAPT  & Captura de evento \textit{Timer} 1    \\ \hline
		0x16 & TIMER1\_COMPA  & Comparação \textit{Timer} 1 canal A    \\ \hline
		0x18 & TIMER1\_COMPB  & Comparação \textit{Timer} 1 canal B    \\ \hline
		0x1A & TIMER1\_OVF  & Estouro do \textit{Timer} 1    \\ \hline
		0x1C & TIMER0\_COMPA  & Comparação \textit{Timer} 0 canal A    \\ \hline
		0x1E & TIMER0\_COMPB  & Comparação \textit{Timer} 0 canal B    \\ \hline
		0x20 & TIMER0\_OVF  & Estouro do \textit{Timer} 0    \\ \hline
		0x22 & SPI STC  & Transferência SPI completa    \\ \hline
		0x24 & USART\_RX  & Recepção USART completa    \\ \hline
		0x26 & USART\_UDRE  & Registrador de dados vazio (USART)    \\ \hline
		0x28 & USART\_TX  & Transmissão USART completa    \\ \hline
		0x2A & ADC  & Conversão analógico-digital completa    \\ \hline
		0x2C & EE READY  & EEPROM pronta    \\ \hline
		0x2E & ANALOG COMP  & Comparador analógico    \\ \hline
		0x30 & TWI & Interface serial $I^{2}C$ \\ \hline
		0x32 & SPM READY & Armazenamento na memória de programa \\ \hline
	\end{tabular}
\end{table}

\par As interrupções são classificadas em duas classes: as disparadas por envento e as disparadas por uma condição. Quando as interrupções são disparadas por eventos, é habilitada uma \textit{flag} toda vez que o evento ocorre e, se a interrupção deste evento estiver ativa, ela será tratada ou enfileirada para tratamento posterior. Ou seja, em interrupções por evento, os eventos que não são tratados, são lembrados, e serão executados em ordem de prioridade assim que possível.
\par Já quando o disparo ocorre por uma condição, a chamada para a rotina de interrupção permanece ativa enquanto a condição estiver presente. Este tipo de interrupção não necessariamente habilita \textit{flag} de modo que, se a condição for removida antes que a CPU possa tratar a interrupção correspondente, esta não ocorrerá.

\subsection{Memória de Programa}
\label{sec:memoria_programa}

\par A memória de programa é uma FLASH de 32kB x 8-bits, que está organizada da forma 16kB x 16-bits pois cada instrução do microcontrolador é de 16 ou 32-bits. Assim, o registrador PC de 14-bits pode fazer um endereçamento a palavra na memória de programa. 
\par A figura~\ref{program_memory} mostra a organização da memória de programa. Pode-se notar que o \textit{Boot Loader} está posicionado em uma seção separada do restante da memória e isso ocorre por questões de segurança.

 \begin{figure}[h]
	\centering
	\includegraphics[scale=0.45]{./Resources/program_memory}
	\caption{Memória de programa ATmega328P}
	Fonte: Folha de dados ATmega328P
	\label{program_memory}
\end{figure}

\par As instruções a serem preenchidas na memória de programa são fornecidas pelo arquivo hexadecimal gerado pelo compilador. Este arquivo segue o padrão Intel e está disposto conforme mostra a tabela~\ref{tab:intel_hex}~\cite{IntelHex}:

\begin{table}[h]
	\centering
	\caption{Formato dos registros do arquivo hexadecimal no padrão Intel}
	\label{tab:intel_hex}
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		Início do registro & Contagem de bytes & Endereço &  Tipo de registro & Dado & \textit{Checksum} \\ \hline
	\end{tabular}
\end{table}

\begin{itemize}
	\item \textbf{Início do registro}: Denotado pelo símbolo ":" (1 byte do registro).
	\item \textbf{Contagem de bytes}: Indica a quantidade de bytes a serem lidos no campo de dados (1 byte do registro).
	\item \textbf{Endereço}: Indica o endereço de memória no qual deve se iniciar o preenchimento dos dados. Este endereço pode não ser igual ao endereço físico da memória (2 bytes do registro).
	\item \textbf{Tipo do registro}: Indica o que o registro representa (1 byte do registro), podendo ser:
	
	\begin{itemize}
		\item 00: Dado
		\item 01: Fim do arquivo
		\item 02: Segmento estendido de memória (o valor do campo "dado" é armazenado e o endereço físico de memória dos registros seguintes é calculado como sendo o campo de endereço somado ao segmento estendido multiplicado por 16).
		\item 03: Início do segmento de memória (o valor contido no campo "dado" é carregado para os registradores CS e IP para os processadores 8086 e 80186).
		\item 04: Segmento estendido de memória Linear (o valor do campo "dado" é armazenado e o endereço físico de memória dos registros seguintes é calculado como sendo o campo de endereço concatenado ao segmento estendido, sendo este último a parte mais significativa do endereço).
		\item 05: Início do endereço linear (aponta para o endereço de memória onde o programa deve iniciar a execução).
	\end{itemize}

	\item \textbf{Dado}: Contém os dados do registro no formato \textit{Little-endian} (primeiro byte é o menos significativo da palavra) (tamanho variável no registro).
	
	\item \textit{\textbf{Checksum}}: Complemento de dois do byte menos significativo da soma de todos os bytes anteriores do registro (1 byte do registro).	
\end{itemize}

\subsection{Memória de Dados}

\par O ATmega328P possui 2kB de memória de dados SDRAM, além do espaço de dados reservado aos registradores.
\par Apesar dos registradores não estarem fisicamente implementados na memória de dados, o microcontrolador faz um mapeamento linear da memória de modo a se obter, na prática, uma memória como mostrado na figura~\ref{data_memory}.

 \begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/data_memory}
	\caption{Memória de dados ATmega328P}
	Fonte: Folha de dados ATmega328P
	\label{data_memory}
\end{figure}

\par Existem diferentes modos de endereçamento que são aplicados à memória de dados. Todo o espaço de endereçamento suporta qualquer um dos modos listados, são eles:
\newpage
\begin{itemize}
	\item \textbf{Direto}: Acesso direto ao endereço desejado.
	\item \textbf{Indireto com deslocamento}: Acesso à 63 endereços deslocados a partir do endereço base, dado pelos registradores Y ou Z.
	\item \textbf{Indireto}: Acesso ao endereço dado pelos registradores X, Y ou Z.
	\item \textbf{Indireto com pré-decremento}: Registradores X, Y ou Z são decrementados antes de serem utilizados como ponteiro para endereçamento.
	\item \textbf{Indireto com pós-incremento}: Registradores X, Y ou Z são incrementados após terem sido utilizados como ponteiro para endereçamento.
\end{itemize}


\subsection{Módulo de Entrada e Saída Digital}
\label{sec:e_s}

\par Como dito anteriormente, o ATmega328P possui 23 pinos programáveis, que podem ser utilizados para entrada ou saída de sinal. A figura~\ref{fig:io_module} mostra a organização interna do módulo de E/S do microcontrolador.

 \begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/io_module}
	\caption{Organização do módulo de Entrada/Saída (E/S) do ATmega328P}
	Fonte: Folha de dados ATmega328P
	\label{fig:io_module}
\end{figure}

\par Os pinos podem ser configurados por meio dos registradores DDRxn e PORTxn, onde "x" corresponde à letra que identifica o \textit{port} e "n" corresponde ao número do bit no registrador. O registrador DDRxn é utilizado para configuração da direção do pino (entrada ou saída), enquanto o PORTxn configura o estado do pino (nível alto ou baixo) se este for um pino de saída, caso contrário, seu efeito será ativar ou desativar o resistor de \textit{pull-up} interno (se este estiver habilitado no registrador MCUCR).
\par Existe ainda o registrador PINxn, que é um registrador responsável por armazenar o valor da entrada do pino. Apesar de ser um registrador de leitura, é possível fazer a escrita do valor "1" (nível alto) via \textit{software}. O efeito desta escrita será a inversão do valor contido no registrador PORTxn, independente da configuração do pino como entrada ou saída.
\par Além de entrada e saída digital, alguns pinos possuem funções adicionais, tais como entrada analógica, saída de PWM, etc., que são multiplexadas ao funcionamento normal do pino.
\par O módulo de E/S pode disparar interrupções externas (pinos INT) ou interrupções por mudança de estado (pinos PCINT). Os pinos INT podem ser configurados, podendo gerar interrupção por mudança de estado, borda de subida/descida ou disparo por nível baixo. Já os pinos PCINT não podem ser configurados e apenas geram interrupção por mudança de estado na entrada. É interessante notar que as interrupções por nível são detectadas de maneira assíncrona, podendo ser utilizadas para despertar o sistema se este estiver em determinados modos de hibernação.
\vfill

\subsection{Temporizadores}
\label{sec:timers}

\par Estão integrados 3 temporizadores no ATmega328P, chamados \textit{Timer 0},\textit{Timer 1} e \textit{Timer 2}. Os modos de funcionamento disponíveis para cada temporizador são semelhantes, sendo eles: modo normal, modo CTC, \textit{Fast PWM} e PWM com correção de fase. As fontes de \textit{clock} para os temporizadores podem ser externa ou interna. Quanto interna, existe a possibilidade de controle da frequência por meio de um \textit{prescaler}.
\par O \textit{Timer 1} é um contador de 16-bits, enquanto os \textit{Timers 0} e \textit{2} são de 8-bits. O \textit{Timer 2} possui uma função adicional de funcionamento assíncrono, podendo assim utilizar uma fonte de \textit{clock} externa aplicada aos pinos TOSC1 e TOSC2 (os \textit{Timers 0} e \textit{1}, embora também possam ser acionados por clock externo, a detecção de borda que é realizada nos pinos T0 e T1 é feita de maneira síncrona). Quando em funcionamento assíncrono, o \textit{Timer 2} pode ser utilizado para despertar o sistema caso este esteja em determinados modos de hibernação. 
\par Os temporizadores podem atuar nos pinos de saída OCxA e OCxB, sobrescrevendo a operação normal do pino. Para isso, entretanto, é preciso que os pinos sejam configurados como saída no registrador DDRxn.
\par As figuras~\ref{fig:timer0_2} e~\ref{fig:timer1} apresentam a organização interna dos \textit{Timers 0/2} e do \textit{Timer 1} respectivamente. Os modos de operação disponíveis para os temporizadores são descritos a seguir.

 \begin{figure}
	\centering
	\includegraphics[width=\textwidth]{./Resources/timer0_2}
	\caption{Organização do módulo de \textit{Timer 0/2} do ATmega328P}
	Fonte: Folha de dados ATmega328P
	\label{fig:timer0_2}
\end{figure}

 \begin{figure}
	\centering
	\includegraphics[width=\textwidth]{./Resources/timer1}
	\caption{Organização do módulo de \textit{Timer 1} do ATmega328P. Para contar em 16-bits, os registradores TCNTn, ICRn, OCRnA e OCRnB são divididos em dois registradores de 8-bits (\textit{LOW} e \textit{HIGH})}
	Fonte: Folha de dados ATmega328P
	\label{fig:timer1}
\end{figure}

\subsubsection{Modo Normal}

\par O modo normal de operação é o mais simples. Nele, a contagem é feita continuamente até atingir o valor máximo (0xFF para 8-bits e 0xFFFF para 16-bits), quando ocorre um \textit{overflow} e o sistema reinicia a contagem do zero, como mostrado no diagrama da figura~\ref{fig:timer_normal_diagrama}. O estouro do contador pode ser utilizado para gerar uma interrupção.
\par Os registradores OCRnA e OCRnB são continuamente comparados com o valor de TCNTn (que armazena a contagem) e em caso de \textit{match}, podem gerar interrupções no sistema e/ou atuar nos pinos OCxA e OCxB, podendo levá-los à nível alto, baixo ou inverter seus valores.

 \begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/timer_normal_mode}
	\caption{Diagrama de funcionamento do modo normal}
	Fonte: Autor
	\label{fig:timer_normal_diagrama}
\end{figure}

\subsubsection{Modo CTC}

\par O modo de funcionamento CTC apresenta as mesmas possibilidades do modo normal, no entanto o valor máximo de contagem é igual ao valor contido no registrador OCRxA, que pode ser ajustado a qualquer momento (para o \textit{Timer 1}, existe também a opção de utilizar o registrador ICR1). O diagrama de funcionamento deste modo é mostrado na figura~\ref{fig:timer_ctc_diagrama}.
\vfill
 \begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/timer_ctc_mode}
	\caption{Diagrama de funcionamento do modo CTC}
	Fonte: Autor
	\label{fig:timer_ctc_diagrama}
\end{figure}

\par No entanto, diferente do modo normal, o reinício da contagem não pode gerar interrupção de \textit{overflow}. Isso só é possível caso OCRxA (ou ICR1) seja igual à 0xFF (8-bits) ou 0xFFFF (16-bits). Neste caso, o modo CTC e o modo normal se comportam de maneiras idênticas.

\subsubsection{Modo \textit{Fast PWM}}

\par No modo \textit{fast PWM}, assim como no modo normal, a contagem é feita continuamente do valor mais baixo (0) ao valor mais alto (0xFF para 8-bits ou, no caso do \textit{Timer 1}, este valor pode ser configurado para 0xFF, 0x1FF ou 0x3FF), havendo a possibilidade de alteração deste valor utilizando o registrador OCRnA (ou ICR1 para o \textit{Timer 1}), como ocorre no modo CTC. Também como no modo normal, o estouro do contador pode gerar interrupção de \textit{overflow}. A figura~\ref{fig:timer_fastpwm_diagram} mostra o diagrama de funcionamento deste modo.
\par A diferença do modo \textit{fast PWM} está na maneira como um \textit{math} entre TCNTn e OCRnA/OCRnB é tratado. Além das possibilidades de disparo de interrupção, os pinos OCxA/OCxB podem ser configurados para apresentar nível baixo em caso de \textit{math} e nível alto no estouro do contador (modo de funcionamento não-invertido), ou o contrário (modo de funcionamento invertido) de modo a gerar uma onda quadrada.

\par Outra característica do modo \textit{fast PWM} está na atualização dos valores de OCRnA/OCRnB. Enquanto no modo normal e no modo CTC estes valores são atualizados imediatamente, no modo \textit{fast PWM} a atualização dos valores ocorre apenas quando TCNTn atinge o valor máximo da contagem. Com isso, evita-se que uma comparação seja perdida caso o valor de OCRnA/OCRnB seja menor que o valor de TCNTn, o que pode ocorrer nos modos normal e CTC.

 \begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/timer_fastpwm_mode}
	\caption{Diagrama de funcionamento do modo \textit{fast PWM}}
	Fonte: Autor
	\label{fig:timer_fastpwm_diagram}
\end{figure}

\subsubsection{Modo PWM com Correção de Fase}

\par O modo PWM com correção de fase faz a contagem progressiva até o valor máximo (fixo ou variável, da mesma forma como ocorre no modo \textit{fast PWM}), seguido de uma contagem regressiva até o valor mínimo (0), quando é disparada a condição de \textit{overflow}. Esta característica, faz com que este modo atinga velocidades 2x menor que o modo \textit{fast PWM}. A figura~\ref{fig:timer_phasecorrect_diagram} apresenta o diagrama de funcionamento deste modo.

\par Neste modo de operação, os pinos OCxA/OCxB podem ser configurados para apresentar nível baixo em caso de \textit{math} (TCNTn e OCRxA/OCRxB) na contagem progressiva, e nível alto em caso de \textit{math} na contagem regressiva (ou o contrário), gerando uma onda quadrada. No caso do \textit{Timer 1}, ainda existe a possibilidade de inverter o valor de OC1A a cada \textit{match}, seja em contagem progressiva ou regressiva.

\par Assim como no modo \textit{fast PWM}, a atualização do valor de OCRxA/OCRxB não é instantânea, ocorrendo apenas no momento em que que a contagem atinge o valor máximo. Importante resaltar que, tanto para o modo de correção de fase, quanto para o \textit{fast PWM}, o valor de ICR1 é atualizado imediatamente, o que pode ocasionar em uma perda na comparação com TCNTx caso este registrador estiver sendo usado para definir o topo da contagem.

 \begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/timer_phasecorrect_mode}
	\caption{Diagrama de funcionamento do modo PWM com Correção de Fase}
	Fonte: Autor
	\label{fig:timer_phasecorrect_diagram}
\end{figure}

\subsubsection{Modo PWM com Correção de Fase e Frequência}

\par Este modo de operação está disponível apenas para o \textit{Timer 1}. Seu funcionamento é idêntico ao modo de correção de fase, a diferença está no momento da atualização dos registradores OCRxA/OCRxB, que não ocorre no topo da contagem mas sim ao atingir o valor mínimo, como mostra a figura~\ref{fig:timer_phasefrequencycorrect_diagram}. Esta mudança faz com que os pulsos gerados sejam sempre simétricos.

 \begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{./Resources/timer_phasefrequencycorrect_mode}
	\caption{Diagrama de funcionamento do modo PWM com Correção de Fase e Frequência}
	Fonte: Autor
	\label{fig:timer_phasefrequencycorrect_diagram}
\end{figure}

\subsubsection{Captura de Eventos}

\par O \textit{Timer 1} apresenta uma funcionalidade extra que é a captura de eventos. Esta funcionalidade permite que o valor da contagem presente em TCNTx seja capturado e salvo no registrador ICR1. 
\par O disparo do evento de captura pode ser dado pela saída do comparador analógico ou pelo pino ICP1, que pode ser configurado para disparo por borda de subida ou descida.
\par Se o registrador ICR1 não estiver sendo utilizado como valor máximo do contador, esta é a única forma de escrever neste registrador.

\subsection{Conversor A/D}
\label{sec:conversor_ad}

\par O ATmega328P possui um conversor A/D de aproximações sucessivas com resolução de 10-bits e 8 canais de entrada (ADC0-ADC7) multiplexados, além de duas entradas fixas (0V e 1,1V) e um sensor de temperatura integrado. A figura~\ref{fig:adc} apresenta a organização interna do conversor A/D.

\par O conversor possui uma entrada de alimentação separada que é feita por meio do pino AVcc. Esta entrada pode ser utilizada como tensão de referência ($V_{ref}$) para conversão, ou ainda, podem ser escolhidas outras opções por meio do registrador ADMUX, tais como o pino AREF ou referência interna de 1,1V.

\par Por ser um conversor de 10-bits, são necessários 2 registradores para armazenar o resultado da conversão, são eles o ADCL e o ADCH. O resultado da conversão é alinhado à esquerda por padrão, no entanto esta opção pode ser alterada para alinhamento à direita por meio do registrador ADMUX. A figura~\ref{fig:alinhamento} mostra como o resultado é armazenado nos registradores ADCL e ADCH para cada modo.

\begin{figure}[h]
	\centering
	\begin{subfigure}{0.75\textwidth}
		\centering
		\includegraphics[width = \textwidth]{./Resources/adc_left_align}
		\caption{Alinhamento à esquerda}
	\end{subfigure}
	
	%Line Break
	
	\begin{subfigure}{0.75\textwidth}
		\centering
		\includegraphics[width = \textwidth]{./Resources/adc_right_align}
		\caption{Alinhamento à direita}
	\end{subfigure}
	\caption{Alinhamento do resultado nos registradores ADCH e ADCL}
	Fonte: Autor.
	\label{fig:alinhamento}
\end{figure}

 \begin{figure}
	\centering
	\includegraphics[width=\textwidth]{./Resources/adc}
	\caption{Organização do conversor A/D}
	Fonte: Folha de dados ATmega328P
	\label{fig:adc}
\end{figure}

\par Por segurança, uma leitura no registrador ADCL bloqueia a permissão de escrita nos registradores ADCL e ADCH, garantindo assim que o dado lido é referente à mesma conversão (o acesso é liberado novamente ao realizar uma leitura em ADCH). Caso o resultado esteja alinhado à direita, pode-se obter um valor convertido de 8-bits apenas lendo o registrador ADCH.

\par Para iniciar uma conversão é necessário colocar em nível alto os bits ADEN (habilita o conversor) e ADSC. A conversão é então inicializada e ADSC permanece em nível alto durante todo o tempo de conversão. Ao final, o bit ADSC é resetado por \textit{hardware} e a \textit{flag} ADIF é setada, podendo gerar uma interrupção se esta estiver configurada. O resultado de uma conversão é dada pela equação~\ref{eq:adc_result}.

\begin{equation}
	ADC = \frac{V_{in} \cdot 1024}{V_{ref}}
	\label{eq:adc_result}
\end{equation}

\par Onde $V_{in}$ é a tensão aplicada à entrada do microcontrolador e ADC é o valor (decimal) convertido. Valores de entrada superiores à $V_{ref}$ terão valores convertidos próximos à 0x3FF (valor máximo para 10-bits).

\par É possível configurar um evento para o disparo do conversor A/D ou utilizá-lo no modo \textit{Free Run}, em que o disparo é feito pela própria \textit{flag} do conversor (ADIF), fazendo com que uma nova conversão comece imediatamente após a outra. Para utilizar este modo, a \textit{flag} ADIF precisa ser limpa a cada conversão, o que é feito automaticamente se for utilizada interrupção. A tabela~\ref{tab:disparo_adc} apresenta todas as possibilidades de disparo do conversor A/D.

\begin{table}[h]
	\centering
	\caption{Modos de disparo do conversor A/D}
	\label{tab:disparo_adc}
	\begin{tabular}{|c|c|}
		\hline
		ADTS[2:0] & Disparo \\ \hline
		000& Modo \textit{Free Run}  \\ \hline
		001& Saída do comparador analógico \\ \hline
		010& Interrupção externa 0 \\ \hline
		011& \textit{Math} A \textit{Timer} 0 \\ \hline
		100& \textit{Overflow Timer 0} \\ \hline
		101& \textit{Math} B \textit{Timer} 1 \\ \hline
		110& \textit{Overflow Timer 1} \\ \hline
		111& Captura de evento \textit{Timer} 1 \\ \hline
	\end{tabular}
\end{table}

\par Um recurso extra oferecido pelo microcontrolador é o sensor de temperatura integrado. Este sensor é capaz de realizar medições entre -45\textdegree C e 85\textdegree C, com precisão de $\pm$10\textdegree C. 
\par Para utilizar este sensor, é preciso configurar o $V_{ref}$ para a entrada interna de 1,1V. A temperatura (em \textdegree C) é dada pela equação~\ref{eq:adc_temperatura}.

\begin{equation}
	T = \frac{[ADCH << 8 | ADCL] - T_{OS}}{k}
	\label{eq:adc_temperatura}
\end{equation}

\par Onde $T_{OS}$ é um valor inserido na EEPROM de cada componente como parte dos testes em produção, ADCH e ADCL são os valores contidos nos respectivos registradores e k é um valor a ser determinado na calibração. (Na prática, utiliza-se $T_{OS}$ = 324,31 e k = 1,22~\cite{Sensor_Temperatura})

\subsection{USART}
\label{sec:usart}

\par A USART é um dos módulos do Atmega328P que permitem a comunicação serial deste com outros dispositivos. Este módulo possui múltiplos modos de operação, suportando comunicação \textit{full duplex}, operação síncrona e assíncrona, detecção de erros em \textit{frames}, modo de comunicação com multiprocessadores, etc., além de poder ser utilizada para comunicação SPI (como Mestre). A figura~\ref{fig:usart} apresenta a organização interna deste módulo no microcontrolador.

 \begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{./Resources/usart}
	\caption{Organização da USART}
	Fonte: Folha de dados ATmega328P
	\label{fig:usart}
\end{figure}

\par O protocolo de comunicação da USART utiliza \textit{frames} que podem ter 5,6,7,8 ou 9 bits, com 1 ou 2 bits de parada, além da possibilidade de adição de bits de paridade par ou ímpar. Os bits de paridade são utilizados para detecção de erro na transmissão e são calculados pelas equações~\ref{eq:paridade_par} (paridade par) e~\ref{eq:paridade_impar} (paridade ímpar).

\begin{equation}
P_{even} = d_{n-1} \oplus ... \oplus d_3 \oplus d_2 \oplus d_1 \oplus d_0 \oplus 0
\label{eq:paridade_par}
\end{equation}

\begin{equation}
P_{odd} = d_{n-1} \oplus ... \oplus d_3 \oplus d_2 \oplus d_1 \oplus d_0 \oplus 1
\label{eq:paridade_impar}
\end{equation}

\par Onde $d_n$ é o n-ésimo bit de dado a ser transmitido.

\par A transmissão de um \textit{frame} se inicia com o bit de \textit{START}, fazendo a mudança do estado da linha alto (\textit{IDLE}) para o nível baixo, indicando que uma comunicação deve ser iniciada. Os bits do \textit{frame} são então transmitidos um a um, começando pelo bit menos significativo e terminando com o bit de paridade (se houver). Por fim, são enviados os bits de parada (1 ou 2, conforme configurado), indicando o fim do \textit{frame}. Este procedimento está ilustrado na figura~\ref{fig:frame_usart}.

 \begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{./Resources/frame_usart}
	\caption{Formato de um \textit{frame} transmitido pela USART}
	Fonte: Folha de dados ATmega328P
	\label{fig:frame_usart}
\end{figure}

\par Durante a transmissão e a recepção, a USART utiliza um registrador auxiliar UDRn (como mostrado na figura~\ref{fig:usart}). Este registrador é na verdade composto por dois espaços de memória, um acessado por operações de escrita e outro por operações de leitura, e consiste em um \textit{buffer} que recebe os dados a serem transmitidos (antes de serem enviados ao registrador de deslocamento para transmissão) ou os dados recebidos (quando a recepção for concluída).

\par Para utilizar a USART, o programador precisa inicialmente informar a velocidade de comunicação (\textit{BAUD rate}), formato do \textit{frame} e habilitar o transmissor e o receptor. A transmissão se inicia ao carregar um dado no registrador UDRn e a recepção ao receber o bit de \textit{START}. A velocidade de comunicação é ajustada por meio do registrador UBRRn de 16-bits e pode ser calculada pela equação~\ref{eq:baud_rate} (para o modo assíncrono).

\begin{equation}
	\label{eq:baud_rate}
	BAUD = \frac{f_{osc}}{16(UBRRn + 1)}
\end{equation}

\par Onde BAUD é a velocidade de comunicação (bits/s), $f_{osc}$ é a frequência de \textit{clock} do sistema e UBRRn é o valor contido no registrador.

\par A USART pode ser utilizada de modo dirigido por interrupção. Três eventos podem ser configuradas gerar interrupção, são eles:

\begin{itemize}
	\item\textbf{ Recepção completa}: Indica que existe dado não lido no \textit{buffer} de recepção.
	\item \textbf{Registrador de dados vazio}: Indica que o \textit{buffer} de transmissão está pronto para receber um novo dado, ou seja, o dado anterior já foi movido para o registrador de deslocamento. Esta é uma interrupção disparada por condição, persistindo até que um novo dado seja escrito no registrador UDRn ou a interrupção seja desabilitada manualmente.
	\item \textbf{Transmissão completa}: Indica que todos os dados presentes no registrador de deslocamento já foram transmitidos.
\end{itemize}

\par Assim como ocorre com os temporizadores, quando em operação, a USART sobrescreve o funcionamento normal dos pinos PD0 (Rx) e PD1 (Tx).

\newpage
\section{Processo de \textit{Software}}
\par Para a criação de \textit{software} de modo profissional, é fundamental o uso de técnicas que propiciem estabilidade, controle e organização do processo de desenvolvimento~\cite{Pressman}. Diversos são os processos de \textit{software} existentes, cada um com suas características próprias, entre eles, o processo ágil que surge para sanar fraquezas da engenharia de \textit{software} convencional, priorizando a entrega mais do que a  análise de projeto~\cite{Pressman}.

\par O processo ágil mais utilizado no mundo é o SCRUM~\cite{IBM_SCRUM}. Desenvolvido em 1993 por Jeff Sutherland, o SCRUM baseia seu desenvolvimento em ciclos curtos (chamados \textit{Sprints}), onde, ao final de cada ciclo deve ser desenvolvido um módulo funcional do sistema (e este deve estar finalizado). O desenvolvimento em ciclos curtos tem a grande vantagem de gerar resultados constantes, revelando erros rapidamente e permitindo assim que estes sejam corrigidos rapidamente. O fluxo do processo SCRUM é mostrado na figura~\ref{fig:scrum}.

 \begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{./Resources/scrum}
	\caption{Fluxo do processo SCRUM. A figura mostra o fluxo completo considerando \textit{sprints} mensais e reuniões diárias. Neste projeto, os \textit{sprints} foram semanais e as etapas em grupo foram omitidas.}
	Fonte: Pressman~\cite{Pressman}
	\label{fig:scrum}
\end{figure}

\par Como aponta Jeff Sutherland~\cite{Jeff}, a realidade do desenvolvimento de \textit{software} é diferente do que propõe alguns processos convencionais, como o método cascata, onde o planejamento é inteiramente e minunciosamente detalhado para o desenvolvimento posterior. Alteração nos requisitos é algo comum em projetos de \textit{software} e abordagens convencionais não preveem esta possibilidade, ao passo que os métodos ágeis procuram incorporar este dinamismo do desenvolvimento real. Este foi o motivo pelo qual o SCRUM foi escolhido para o desenvolvimento deste trabalho.

\newpage
\section{Teste de \textit{Software}}

\par O desenvolvimento de \textit{software} é uma tarefa complexa e diversos fatores podem contribuir para que a execução de um programa resulte em um comportamento inesperado, sendo que a maioria dos defeitos em \textit{software} são de origem humana, ou seja, um erro cometido pelo programador durante o desenvolvimento~\cite{Delamaro}. Diferentes tipos de erros podem ser cometidos durante o desenvolvimento  e por isso a atividade de teste é dividida em fases, cada qual com um objetivo distinto. Neste projeto, foram realizados apenas testes de unidade, ou seja, testes que focam nas menores unidades de um programa~\cite{Delamaro}, neste caso, os métodos em Java.

\par Diversas são as técnicas e os critérios que podem ser utilizados para testar um \textit{software}. Este trabalho focou no uso de duas técnicas: teste funcional e teste estrutural. 

\par O teste funcional é aquele onde a atividade de teste é voltada para as especificações, ou seja, o funcionamento desejado, sem se preocupar na maneira como o programa foi escrito. O critério adotado para a realização deste teste foi a Análise do Valor Limite. Neste tipo teste, o domínio de entrada (ou seja, o conjunto de todos os possíveis valores que podem ser utilizados como entrada do programa~\cite{Delamaro}) é dividido em classes, de forma que se espera um mesmo comportamento do programa para todos os elementos de uma mesma classe (por isso, estas são chamadas classes de equivalência)~\cite{Delamaro}. O critério se baseia em testar valores que estão nos limites de cada classe de equivalência, ou seja, na transição dos valores de entrada onde o comportamento do programa deve mudar.

\par O teste estrutural, por outro lado, observa a estrutura interna do código para a geração dos casos de teste (par formado por dado de entrada e saída desejada~\cite{Delamaro}). No caso deste projeto, o critério utilizado foi o baseado em fluxo de controle, mais especificamente, o critério de Todos-Nós, onde busca-se a criação de casos de teste que exercite, pelo menos uma vez, cada comando do programa~\cite{Delamaro}.

\par Todos os principais módulos foram testados com técnicas funcionais e estruturais, sendo que o teste estrutural foi o principal (exceto no módulo de CPU).