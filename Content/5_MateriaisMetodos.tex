\chapter{Desenvolvimento do Projeto}
\label{Material}


\par Neste capítulo serão detalhadas as etapas de desenvolvimento do projeto, bem como as ferramentas utilizadas.
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Material}

\par Para a execução do projeto foram necessárias diversas ferramentas para projetar, desenvolver e testar o sistema. A seguir são listados todos os materiais utilizados ao longo do projeto.

\begin{itemize}
\item Para o desenho de diagramas de classe e mapas mentais na fase de projeto, foram utilizadas as ferramentas \textit{Dia}\footnote{\url{http://dia-installer.de/}} e \textit{Draw.io}\footnote{\url{https://www.draw.io/}}, por serem ambas gratuitas, \textit{Open-Source} e com recursos que suprem as necessidades deste projeto.

\item Como já mencionado anteriormente, o método ágil \textit{SCRUM} foi o escolhido para a construção do sistema. Apesar de não ter sido aplicado por completo, com reuniões semanais e outras atividades em grupo (já que é o trabalho foi desenvolvido por uma única pessoa), o desenvolvimento em ciclos, a priorização de tarefas e outras características do SCRUM foram aplicadas para ajudar na organização e no desenvolvimento do simulador. A plataforma \textit{Taiga}\footnote{\url{https://taiga.io/}} foi utilizada para organização e planejamento dos \textit{Sprints} e sua escolha se deve pelo fato de ser gratuito e já ser conhecida pelo autor.

\item Para controle de versão utilizou-se o \textit{Git}\footnote{\url{https://git-scm.com/}} sincronizado à um repositório \textit{on-line} no \textit{Github}\footnote{\url{https://github.com/}}. Nenhum motivo especial na escolha destas ferramentas, a não ser a familiaridade do autor com seu uso.

\item Para documentação do projeto, foi escolhido o \textit{Gitbook}\footnote{\url{www.gitbook.com}} pela possibilidade de hospedar a documentação \textit{on-line}, além de contar com um \textit{design} próprio que torna a documentação mais agradável para leitura e mais organizada.

\item Para o realizar modificações no código da IDE do Arduino, foi utilizado o \textit{InteliJ IDEA}\footnote{\url{https://www.jetbrains.com/idea/}} para escrever o código e o \textit{Apache Ant}\footnote{\url{https://ant.apache.org/}} para a compilação (uma vez que esta ferramenta já é utilizada pelo projeto Arduino).

\item O \textit{Inkscape}\footnote{\url{https://inkscape.org/pt-br/}} foi usado para a alteração no \textit{design} da IDE (inserção do botão "Android"). Nenhum motivo especial suporta esta escolha, apenas o fato de estar disponível facilmente nos repositórios do Arch Linux, sistema operacional utilizado durante o desenvolvimento.

\item Para o desenvolvimento \textit{mobile}, o \textit{Android Studio}\footnote{\url{https://developer.android.com/studio/}} foi a escolha para este projeto. A opção de desenvolver o código nativamente veio principalmente da experiência do autor com esta plataforma, mas também por questões de desempenho. Além disso, o \textit{Android Studio} conta com diversas ferramentas que foram utilizadas na fase de teste, como o \textit{JUnit4}\footnote{\url{https://junit.org/junit4/}} e o \textit{PowerMock}\footnote{\url{https://github.com/powermock/powermock}}, utilizados para criação de teste de unidade, além de ferramentas de \textit{profiling}.

\item O \textit{SonarQube}\footnote{\url{https://www.sonarqube.org/}} foi escolhido para fazer a analise estática do código do simulador. A escolha desta ferramenta se deve pelo fato de ser possível extrair diversas métricas de \textit{software} em uma única aplicação, além de sugestões de correção de \textit{bugs}, vulnerabilidades, entre outros. Além disso, o \textit{plugin} \textit{JaCoCo}\footnote{\url{https://www.eclemma.org/jacoco/}} foi utilizado em conjunto ao \textit{SonarQube} para obter medidas de cobertura de código.

\item Para montar códigos \textit{Assembly} escritos para o ATmega328P, foi utilizado o \textit{AVRA}\footnote{\url{http://avra.sourceforge.net/}}. Também não há motivos especiais para o uso desta ferramenta a não ser por sua facilidade de instalação e uso.

\item Para a criação dos gráficos, foram criados \textit{scripts} em \textit{Python}, fazendo uso da biblioteca \textit{Matplotlib}\footnote{\url{https://matplotlib.org/}}, que possui recursos avançados para geração de gráficos e é de fácil uso. Para gráficos simples, foi utilizado o \textit{Google Sheets}\footnote{\url{https://www.google.com/sheets/about/}}.  

\item Em termos de hardware, foi utilizado um Arduino UNO R3 para comparar os resultados obtidos pelo aplicativo com o sistema real, principalmente comparações feitas em medidas de frequência e \textit{duty cycle}, no qual se fez uso também de um osciloscópio InfiniiVision DSOX2002A, da Keysight.

\item Por fim, o aparelho disponível para realizar os testes foi o smartphone ASUS ZenFone 2, com 4 núcleos de processamento (2,33GHz), 4GB de memória principal e 32GB de armazenamento, executando o
Android 5.0.

\end{itemize}


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\newpage
\section{Método}

\subsection{Desenvolvimento na IDE do Arduino}

\par A primeira parte do desenvolvimento ocorreu na IDE do Arduino. Esta etapa focou na criação do botão "Android", cuja função é compilar o código e transferi-lo para o aparelho Android conectado ao computador, da mesma forma que o botão "\textit{Upload}" faz com a placa de Arduino. 

\par A figura~\ref{fig:diagrama_classes_usb} apresenta o diagrama de classes do código desenvolvido nesta etapa. Para fazer as modificações necessárias, foi necessário inserir o pacote \textit{android\_usb} na pasta \url{app/src/processing/app/} do projeto Arduino, além de editar as classes \textit{EditorToolbar} e \textit{Editor} da mesma pasta para inserir o botão e definir sua funcionalidade, respectivamente (o arquivo contendo a imagem do botão está localizado em \url{build/shared/lib/theme/} e \url{build/linux/work/lib/theme/})

 \begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/usb_class_diagram}
	\caption{Diagrama de classes das modificações realizadas na IDE do Arduino}
	Fonte: Autor
	\label{fig:diagrama_classes_usb}
\end{figure}

\par A classe \textit{DeviceSelector} é a entrada do sistema. Ela recebe como argumento o local onde o hexadecimal é gerado (que pode ser obtido por meio do método \textit{getBuildPath} da classe \textit{Sketch} já existente no projeto do Arduino) e cria a janela para selecionar o dispositivo. Todos os aparelhos Android montados no sistema são exibidos em uma lista em caso de sucesso na compilação. Em conjunto, atua a classe \textit{DeviceWatcher}, que é uma \textit{thread} que fica a procura de novos dispositivos. Desta forma, caso algum aparelho seja conectado após a exibição da janela de seleção, a lista de dispositivos é atualizada automaticamente.

\par Já a classe \textit{USBManager} cuida de toda a comunicação com o sistema e o dispositivo Android, além de fazer a identificação dos dispositivos conectados e retornar ao seletor um \textit{friendly name} para que o usuário possa reconhecer seu dispositivo facilmente. Ao pressionar o botão "Ok" do seletor de dispositivos, o método \textit{copyHexToDevice} é chamado para copiar o arquivo compilado para o dispositivo Android.

\par No Linux, todos os dispositivos MTP são montados por meio do GVfs. Utilizando a variável de ambiente \textit{\$XDG\_RUNTIME\_DIR} é posível acessar o dispositivo como uma pasta no sistema de arquivos. Desta forma, o arquivo hexadecimal é copiado para o local \url{XDG\_RUNTIME\_DIR/gvfs/<Dispositivo>/DCIM/SOFIA} e tem o nome genérico de \textit{code.hex}, tornando o código disponível para o simulador. No Windows, dispositivos MTP são tratados de forma diferente, não sendo montados diretamente no sistema de arquivos, tornando o acesso bastante trabalhoso. Por este motivo, nesta primeira versão do sistema, não foi implementado um método automático para copiar o arquivo hexadecimal para o dispositivo Android no Windows.

\par A classe \textit{USBManager} utiliza alguns comandos externos do sistema, tais como \textit{lsusb}, \textit{gio copy} e \textit{gvfs-copy}. O primeiro comando é necessário apenas para retornar um nome mais legível do dispositivo para o usuário (\textit{friendly name}), mas caso este não seja encontrado o sistema ainda será capaz de funcionar. Já o segundo e o terceiro comando são utilizados para transferir o arquivo para o dispositivo móvel, sendo executados na ordem: primeiro o \textit{gio copy}, seguido do \textit{gvfs-copy} em caso de falha (\textit{gvfs-copy} é um comando antigo, mas foi adicionado para compatibilidade). Se o usuário não tiver pelo menos um destes comandos disponíveis no computador, o sistema informará falha ao copiar o arquivo. Estes três comandos fazem parte do pacote básico de instalação das principais distribuições Linux.

%\par O botão "Android" foi posicionado junto aos demais botões já existentes na IDE, na parte superior esquerda, conforme mostra a figura~\ref{fig:botao_android}.

% \begin{figure}[h]
%	\centering
%	\includegraphics[width=0.5\textwidth]{./Resources/android_button}
%	\caption{Localização do botão "Android" (primeiro da esquerda para a direita) na IDE.} 
%	Fonte: Autor
%	\label{fig:botao_android}
%\end{figure}


\subsection{Desenvolvimento Android}

A segunda parte do desenvolvimento foi a criação do aplicativo para fazer a simulação do código. A figura~\ref{fig:arquitetura_simulador} apresenta um diagrama simplificado da arquitetura do simulador.

 \begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{./Resources/ArduinoSimulator_arquitetura}
	\caption{Arquitetura do simulador} 
	Fonte: Autor
	\label{fig:arquitetura_simulador}
\end{figure}

\subsubsection{Módulo principal}

\par Tudo tem início na classe \textit{UCModule}, que constitui o módulo principal do sistema. Esta classe é responsável por inicializar todos os demais módulos e fazer a sincronização entre eles, além de fornecer serviços para estes módulos no que diz respeito às características do sistema simulado, como a quantidade de pinos, tensão de alimentação, etc. 
\par Esta classe possui uma extensão que é a classe \textit{UCModule\_View}. Ela é responsável por toda a manipulação das telas e recursos visuais do aplicativo, além de fornecer \textit{feedback} à \textit{UCModule} quanto às ações dos botões (como botão \textit{Reset}) e fazer a contagem do tempo simulado. É na \textit{UCModule\_View} que os módulos de entrada e saída são inicializados.

\par Outra tarefa da \textit{UCModule} é atuar como escalonador. Todos os módulos do sistema (CPU, conversor A/D, temporizadores, USART) além do módulo de visualização (\textit{UCModule\_View}) são executados um a um, em uma fila circular, sendo calculado um ciclo de \textit{clock} a cada iteração. A velocidade de execução deste \textit{loop} não foi limitada de nenhuma forma, para que a velocidade de simulação seja a maior possível. Essa abordagem, no entanto, faz com que o simulador sofra variações de velocidade em função da carga no sistema Android.

\par Ainda quanto à sincronia dos módulos, buscou-se preservar o número correto de ciclos de \textit{clock} que cada instrução da CPU leva para executar, bem como chamadas para rotinas de interrupção e \textit{prescalers} dos temporizadores. A exceção fica apenas para o conversor A/D, cujo tempo de conversão é de apenas 1 ciclo de \textit{clock} (originalmente, o Arduino leva cerca de 13 ciclos) e os \textit{prescalers} foram desabilitados para este módulo. Essa mudança se justifica por não afetar de maneira significativa o realismo da simulação, ao mesmo tempo que proporciona um ganho de performance, tornando o sistema mais agradável ao usuário.

\subsubsection{CPU}
\label{teoria_cpu}

\par O próximo módulo, a CPU (\textit{CPUModule}), é responsável pela execução das instruções contidas na memória de programa. Ao final de cada instrução, é feita a verificação por interrupções, que são executadas em ordem de prioridade conforme apresentado na tabela~\ref{interruption_vector}. Todas as instruções do microcontrolador ATmega328P foram implementadas, com exceção das instruções \textit{BREAK}, \textit{SLEEP} e \textit{WDR}.

\par A arquitetura trabalhada não fornece instruções com campos fixos para \textit{opcode}, operadores, etc., o que dificulta a decodificação das instruções. Para que a legibilidade do código não fosse prejudicada com uma série de condicionais aninhadas, a estratégia adotada para a decodificação foi a utilização de um banco de dados com as instruções pré-decodificadas. Desta forma, foi criado um banco de dados com $2^{16}$ posições (tamanho da instrução) e para cada posição foi inserido um identificador (ID) da instrução referente àquela posição em binário. Com isso, ao ler uma instrução da memória de programa, a CPU simplesmente acessa um vetor na posição da instrução lida e recupera a instrução a ser executada (o banco de dados é carregado para a memória durante a exibição do \textit{Splash Screen} ao iniciar o aplicativo). 
\par Apesar do gasto de memória (o tamanho deste banco de dados em memória é de 128kB), esta solução torna o código muito mais legível.

\subsubsection{Memória de Programa} 

\par A memória de programa (\textit{ProgramMemory}) é responsável por armazenar o código a ser executado pela CPU. O código é lido de um arquivo hexadecimal no formato \textit{Intel HEX} e formatado em um \textit{array} de bytes. É também função da memória de programa verificar continuamente o arquivo hexadecimal e enviar uma mensagem de \textit{Reset} para o módulo principal em caso de alterações.

\par Como dito na seção~\ref{sec:memoria_programa}, a memória de programa do ATmega328P é organizada no formato 16kB x 16-bits, no entanto, no simulador, preferiu-se a organização 32kB x 8-bits. Desta forma, a estrutura de dados para armazenar o programa é mais simples (um vetor de bytes), além de facilitar a implementação da instrução LPM, que realiza a leitura de um byte da memória de programa.

\par Cada vez que uma instrução é lida da memória pela CPU, dois bytes são lidos e concatenados. O valor do PC continua se referindo ao valor da próxima instrução enquanto que o endereço dos bytes desta instrução são calculados no método \textit{loadInstruction}.

\subsubsection{Memória de Dados} 

\par A memória de dados (\textit{DataMemory}) é o módulo responsável por armazenar todas as informações dos registradores e da memória SDRAM externa. Além disso, a memória de dados notifica a classe \textit{IOModule} em caso de alteração nos registradores de E/S (PINx, PORTx e DDRx).

\par Alguns registradores são tratados de maneira diferentes no ATmega328P. Pode-se citar, por exemplo, o registrador PINx. Este, como explicado na seção~\ref{sec:e_s}, apesar de ser um registrador de leitura, permite também a escrita de um valor, porém esta escrita escrita não altera o valor do PINx, mas sim, o valor do PORTx. Estes casos foram todos tratados na memória de dados, nos métodos de escrita \textit{writeByte} e \textit{writeBit}. Assim, ao escrever um valor na memória, o endereço é verificado e se um caso especial for detectado, a operação realizada será diferente de uma simples escrita. Também foram escritos métodos especiais para a manipulação dos registradores que são atualizados apenas por \textit{hardware} (como o PINx), bem como para a manipulação das \textit{flags} de interrupção.

\par A memória de dados também fornece informações para o mapa de memória quando este é aberto pelo usuário. Por realizar mais operações de leitura e principalmente devido a maior atualização da tela, a velocidade de simulação diminui quando este recurso está ativo, ficando mais lento quanto mais dinâmica for a porção visível na tela.

\subsubsection{Módulo de Interrupção}

\par Foi desenvolvido um módulo de interrupção (\textit{InterruptionModule}) cuja função é verificar e organizar todos os eventos de interrupção que podem ser gerados. Este módulo recebe requisições dos temporizadores, E/S, conversor A/D e USART, organizando-as em ordem de prioridade. No caso do módulo de E/S, é feita ainda a verificação se houve ou não uma interrupção, por meio de detectores de borda, detecção de nível baixo, etc. 
\par Este módulo também é responsável por armazenar os endereços de desvio das interrupções e fornecer à CPU para a execução das rotinas de interrupção. 
\par Todas as classes do projeto podem acessar o módulo de interrupção estaticamente, por meio da classe \textit{UCModule}.

\subsubsection{Módulo de E/S} 

\par Seguindo para o módulo de entrada e saída, este é dividido em duas partes, cada uma tratando exclusivamente entrada ou saída. A parte de tratamento de entrada é responsável pelo gerenciamento de cada elemento gráfico de entrada, bem como o tratamento de suas ações, enquanto que o pacote de saída faz o mesmo para os elementos gráficos de saída. A classe \textit{IOModule} fica acima destas duas, fazendo a integração para que a classe \textit{UCModule\_View} possa exibir corretamente os elementos de interface com o usuário.

\par Não foi imposta nenhuma restrição quanto à ligação de entradas e saídas no simulador. Isso significa que o usuário pode conectar múltiplas entradas/saídas no mesmo pino, conectar uma entrada analógica em um pino digital (neste caso, serão adotados os valores de tensão da folha de dados para definir nível alto, baixo ou indefinido), conectar entradas digitais em pinos analógicos, etc. Um mecanismo de detecção de curto-circuito (entre entrada e saída, também entre entradas) atua toda vez que uma entrada ou saída é alterada, parando o sistema se alguma condição indevida for detectada. 

\par Foram definidos 3 níveis lógicos no sistema: alto, baixo e alta impedância. O nível de alta impedância é visto apenas na saída. Na entrada, existe ainda um estado indefinido, que envia um valor aleatório para a entrada, ou seja, pode ser interpretado como nível alto ou baixo (exceto se o resistor de \textit{pull-up} interno estiver habilitado).

\subsubsection{Temporizadores} 

\par Foram implementados os 3 temporizadores (\textit{TimerxModule}) presentes no ATmega328P. Eles fornecem todos os modos de funcionamento dos apresentados na seção~\ref{sec:timers}, com exceção do funcionamento assíncrono para o \textit{Timer} 2.

\par Como mostrado no capítulo~\ref{EmbasamentoTeorico}, alguns registradores, tais como a pilha, registradores do \textit{Timer} 1, etc., trabalham em pares (\textit{LOW} e \textit{HIGH}). Em especial, o \textit{Timer} 1 usa um registrador temporário para que a leitura/escrita nos registradores ocorra de maneira sincronizada, ou seja, ao ler um valor de contagem do registrador \textit{LOW}, o registrador \textit{HIGH} é salvo imediatamente para que a leitura seja referente ao mesmo instante de tempo. Da mesma forma, a escrita em um registrador \textit{HIGH} é armazenada em um registrador temporário e só é realizada de fato quando ocorrer uma escrita no registrador \textit{LOW}, fazendo a escrita simultânea das duas partes.

\par Este mecanismo de registrador temporário só foi utilizado para escritas da CPU. No módulo de \textit{Timer} 1, a escrita nos registradores de 16-bits ocorre por meio de um método especial na memória de dados, que faz a escrita das duas partes simultaneamente.

\subsubsection{Conversor A/D} 

\par O conversor A/D (\textit{ADCModule}), assim como os Temporizadores, apresenta todos os módulos de funcionamento descritos na seção~\ref{sec:conversor_ad}, com exceção do sensor de temperatura e do disparo pela saída do comparador analógico (já que este módulo não foi implementado). 

\par Em termos de implementação, este é o módulo menos fiel ao sistema físico original, no entanto, isso não reflete em uma simulação incorreta.

\subsubsection{USART}

\par Por fim, a USART (\textit{USARTModule}), apesar de possuir diversos modos de operação no sistema físico original, possui apenas um modo de operação no simulador: \textit{frames} de 8 bits, sem paridade e um bit de parada. Esta configuração foi escolhida por ser a inicialização padrão da função \textit{Serial.begin()} do Arduino (embora outras configurações também sejam possíveis).

\par Este módulo se comunica com um monitor serial que foi integrado ao sistema e ocupa o mesmo espaço reservado aos pinos de saída na tela. Uma característica deste módulo é que a configuração de velocidade (\textit{BAUD rate}) não importa para o seu funcionamento, ou seja, o comportamento do sistema será o mesmo para qualquer velocidade de comunicação.

\hfil

\par Voltando na figura~\ref{fig:arquitetura_simulador}, pode-se observar que as comunicações ocorrem sempre por meio de interfaces (exceto para envio de dados, que precisam partir dos módulos). Este \textit{design} isola toda a parte de controle do funcionamento dos módulos específicos do ATmega328P, o que facilita a expansão do sistema já que, para suportar uma nova plataforma, basta escrever novos módulos de \textit{Timer}, conversor A/D, etc., que implementem as mesmas interfaces. As únicas classes que são acessados diretamente são a \textit{UCModule\_View} (que é própria do aplicativo) e a \textit{CPUModule} (que é própria da arquitetura AVR).
